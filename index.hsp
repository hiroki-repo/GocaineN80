;Gocaine-N80(PC-8001 Emulator) by Gocaine project
;codename:Kiskan-lexiconbricks
;This software is unlicensed!
;so,you can use this software freely!

#packopt name "GOCAINEN80"
#runtime "hsp3hg"
#packopt icon "gn80.ico"
#include "migs.as"
#include "arduino.as"
#include "hspext.as"
#include "mod_joystick.as"
#include "user32.as"
;#include "kernel32.as"
#include "hgimg3.as"
#uselib "crtdll.dll"
#cfunc time "time" int
#cfunc mktime "mktime" int
#cfunc localtime "localtime" int
#cfunc gmtime "gmtime" int
dim timexforch1,9
timexforch1(0)=gettime(6),gettime(5),gettime(4),gettime(3),gettime(1)-1,gettime(0)-1909,0,0,0
ldim oaeptr,2
ldim oaearchptr,1
oae=0
oaeptr(0)=*memoryaccesshnd,*oaemah
#define __useslowz80jitemulation_flag__
#module
#deffunc z80memaccess int prm_0,int prm_1,int prm_2
_z80_addr@=prm_0
_z80_data@=prm_1
_z80_accesstype@=prm_2
goto oaeptr@((oae@)!0)
//goto *memoryaccesshnd@
#global
#include "z80.as"
#include "z80jit.as"
oprestruct=1
z80jitintervalset 65536
z80jitintervaljobset *vblupdatejob
z80jitrectset *vblupdatejob2
dim palhg,3,256
#module
#deffunc fontrend int prm_0
repeat 8:y=cnt
repeat 8:x=cnt
if (peek(fontrom@,prm_0*8+y)<<x)&128{pset ginfo(22)+x,ginfo(23)+y}
loop
loop
pos ginfo(22)+8,ginfo(23)
return
#deffunc fontrend_hg int prm_0
repeat 8:y=cnt
repeat 8:x=cnt
if (peek(fontrom@,prm_0*8+y)<<x)&128{hgrect ginfo(22)+(x*2),ginfo(23)+(y*2)+2,0,2,2}
loop
loop
pos ginfo(22)+16,ginfo(23)
return
#deffunc palette_hg int prm_0,int prm_1,int prm_2,int prm_3
prm_0x=prm_0&0xFF
palhg@(0,prm_0x)=prm_1
palhg@(1,prm_0x)=prm_2
palhg@(2,prm_0x)=prm_3
return
#deffunc palcolor_hg int prm_0
prm_0x=prm_0&0xFF
color palhg@(0,prm_0x),palhg@(1,prm_0x),palhg@(2,prm_0x)
return
#global
repeat 256:prm_0x=cnt
if prm_0x<8{
palette_hg cnt,((prm_0x>>1)&0x01)*255,((prm_0x>>2)&0x01)*255,((prm_0x>>0)&0x01)*255
}
if prm_0x=8{
palette_hg cnt,0,0,0
}
if prm_0x=9{
palette_hg cnt,255,255,255
}
if prm_0x<24 and prm_0x>15{
prm_0x-=16
palette_hg cnt,((prm_0x>>1)&0x01)*230,((prm_0x>>2)&0x01)*230,((prm_0x>>0)&0x01)*230
}
if prm_0x=24{
palette_hg cnt,0,0,0
}
if prm_0x=25{
palette_hg cnt,230,230,230
}
/*if prm_0x<40 and prm_0x>31{
if cnt=3 or cnt=7{palette cnt,0,0,0,(cnt=7)}else{palette cnt,((cnt>>0)&0x01)*255,((cnt>>1)&0x01)*255,((cnt>>2)&0x01)*255,(cnt=7)}
}
if prm_0x<56 and prm_0x>47{
if cnt=3 or cnt=7{palette cnt+0x10,0,0,0,(cnt=7)}else{palette cnt+0x10,((cnt>>0)&0x01)*230,((cnt>>1)&0x01)*230,((cnt>>2)&0x01)*230,(cnt=7)}
}*/
loop

#include "ipmpackb.hsp"
#ifndef _WAVEOUT_H_
#define _WAVEOUT_H_
;(winmm.as)
#ifdef __hsp30__
#ifndef __WINMM__
#define global __WINMM__
#uselib "WINMM.DLL"
	#func global CloseDriver "CloseDriver" sptr,sptr,sptr
	#func global DefDriverProc "DefDriverProc" sptr,sptr,sptr,sptr,sptr
	#func global DriverCallback "DriverCallback" sptr,sptr,sptr,sptr,sptr,sptr,sptr
	#func global DrvGetModuleHandle "DrvGetModuleHandle" sptr
	#func global GetDriverModuleHandle "GetDriverModuleHandle" sptr
	#func global MigrateAllDrivers "MigrateAllDrivers"
	#func global MigrateMidiUser "MigrateMidiUser"
	#func global MigrateSoundEvents "MigrateSoundEvents"
	#func global NotifyCallbackData "NotifyCallbackData" sptr,sptr,sptr,sptr,sptr
	#func global OpenDriver "OpenDriver" sptr,sptr,sptr
	#func global PlaySound "PlaySound" sptr,sptr,sptr
	#func global PlaySoundA "PlaySoundA" sptr,sptr,sptr
	#func global PlaySoundW "PlaySoundW" wptr,wptr,wptr
	#func global SendDriverMessage "SendDriverMessage" sptr,sptr,sptr,sptr
	#func global WOW32DriverCallback "WOW32DriverCallback" sptr,sptr,sptr,sptr,sptr,sptr,sptr
	#func global WOW32ResolveMultiMediaHandle "WOW32ResolveMultiMediaHandle" sptr,sptr,sptr,sptr,sptr,sptr
	#func global WOWAppExit "WOWAppExit" sptr
	#func global aux32Message "aux32Message" sptr,sptr,sptr,sptr,sptr
	#define global auxGetDevCaps auxGetDevCapsA
	#func global auxGetDevCapsA "auxGetDevCapsA" sptr,sptr,sptr
	#func global auxGetDevCapsW "auxGetDevCapsW" wptr,wptr,wptr
	#func global auxGetNumDevs "auxGetNumDevs"
	#func global auxGetVolume "auxGetVolume" sptr,sptr
	#func global auxOutMessage "auxOutMessage" sptr,sptr,sptr,sptr
	#func global auxSetVolume "auxSetVolume" sptr,sptr
	#func global joy32Message "joy32Message" sptr,sptr,sptr,sptr,sptr
	#func global joyConfigChanged "joyConfigChanged" sptr
	#define global joyGetDevCaps joyGetDevCapsA
	#func global joyGetDevCapsA "joyGetDevCapsA" sptr,sptr,sptr
	#func global joyGetDevCapsW "joyGetDevCapsW" wptr,wptr,wptr
	#func global joyGetNumDevs "joyGetNumDevs"
	#func global joyGetPos "joyGetPos" sptr,sptr
	;#func global joyGetPosEx "joyGetPosEx" sptr,sptr
	#func global joyGetThreshold "joyGetThreshold" sptr,sptr
	#func global joyReleaseCapture "joyReleaseCapture" sptr
	#func global joySetCapture "joySetCapture" sptr,sptr,sptr,sptr
	#func global joySetThreshold "joySetThreshold" sptr,sptr
	#func global mci32Message "mci32Message" sptr,sptr,sptr,sptr,sptr
	#func global mciDriverNotify "mciDriverNotify" sptr,sptr,sptr
	#func global mciDriverYield "mciDriverYield" sptr
	#func global mciExecute "mciExecute" sptr
	#func global mciFreeCommandResource "mciFreeCommandResource" sptr
	#func global mciGetCreatorTask "mciGetCreatorTask" sptr
	#define global mciGetDeviceID mciGetDeviceIDA
	#func global mciGetDeviceIDA "mciGetDeviceIDA" sptr
	#define global mciGetDeviceIDFromElementID mciGetDeviceIDFromElementIDA
	#func global mciGetDeviceIDFromElementIDA "mciGetDeviceIDFromElementIDA" sptr,sptr
	#func global mciGetDeviceIDFromElementIDW "mciGetDeviceIDFromElementIDW" wptr,wptr
	#func global mciGetDeviceIDW "mciGetDeviceIDW" wptr
	#func global mciGetDriverData "mciGetDriverData" sptr
	#define global mciGetErrorString mciGetErrorStringA
	#func global mciGetErrorStringA "mciGetErrorStringA" sptr,sptr,sptr
	#func global mciGetErrorStringW "mciGetErrorStringW" wptr,wptr,wptr
	#func global mciGetYieldProc "mciGetYieldProc" sptr,sptr
	#func global mciLoadCommandResource "mciLoadCommandResource" sptr,sptr,sptr
	#define global mciSendCommand mciSendCommandA
	#func global mciSendCommandA "mciSendCommandA" sptr,sptr,sptr,sptr
	#func global mciSendCommandW "mciSendCommandW" wptr,wptr,wptr,wptr
	#define global mciSendString mciSendStringA
	#func global mciSendStringA "mciSendStringA" sptr,sptr,sptr,sptr
	#func global mciSendStringW "mciSendStringW" wptr,wptr,wptr,wptr
	#func global mciSetDriverData "mciSetDriverData" sptr,sptr
	#func global mciSetYieldProc "mciSetYieldProc" sptr,sptr,sptr
	#func global mid32Message "mid32Message" sptr,sptr,sptr,sptr,sptr
	#func global midiConnect "midiConnect" sptr,sptr,sptr
	#func global midiDisconnect "midiDisconnect" sptr,sptr,sptr
	#func global midiInAddBuffer "midiInAddBuffer" sptr,sptr,sptr
	#func global midiInClose "midiInClose" sptr
	#define global midiInGetDevCaps midiInGetDevCapsA
	#func global midiInGetDevCapsA "midiInGetDevCapsA" sptr,sptr,sptr
	#func global midiInGetDevCapsW "midiInGetDevCapsW" wptr,wptr,wptr
	#define global midiInGetErrorText midiInGetErrorTextA
	#func global midiInGetErrorTextA "midiInGetErrorTextA" sptr,sptr,sptr
	#func global midiInGetErrorTextW "midiInGetErrorTextW" wptr,wptr,wptr
	#func global midiInGetID "midiInGetID" sptr,sptr
	#func global midiInGetNumDevs "midiInGetNumDevs"
	#func global midiInMessage "midiInMessage" sptr,sptr,sptr,sptr
	#func global midiInOpen "midiInOpen" sptr,sptr,sptr,sptr,sptr
	#func global midiInPrepareHeader "midiInPrepareHeader" sptr,sptr,sptr
	#func global midiInReset "midiInReset" sptr
	#func global midiInStart "midiInStart" sptr
	#func global midiInStop "midiInStop" sptr
	#func global midiInUnprepareHeader "midiInUnprepareHeader" sptr,sptr,sptr
	#func global midiOutCacheDrumPatches "midiOutCacheDrumPatches" sptr,sptr,sptr,sptr
	#func global midiOutCachePatches "midiOutCachePatches" sptr,sptr,sptr,sptr
	#func global midiOutClose "midiOutClose" sptr
	#define global midiOutGetDevCaps midiOutGetDevCapsA
	#func global midiOutGetDevCapsA "midiOutGetDevCapsA" sptr,sptr,sptr
	#func global midiOutGetDevCapsW "midiOutGetDevCapsW" wptr,wptr,wptr
	#define global midiOutGetErrorText midiOutGetErrorTextA
	#func global midiOutGetErrorTextA "midiOutGetErrorTextA" sptr,sptr,sptr
	#func global midiOutGetErrorTextW "midiOutGetErrorTextW" wptr,wptr,wptr
	#func global midiOutGetID "midiOutGetID" sptr,sptr
	#func global midiOutGetNumDevs "midiOutGetNumDevs"
	#func global midiOutGetVolume "midiOutGetVolume" sptr,sptr
	#func global midiOutLongMsg "midiOutLongMsg" sptr,sptr,sptr
	#func global midiOutMessage "midiOutMessage" sptr,sptr,sptr,sptr
	#func global midiOutOpen "midiOutOpen" sptr,sptr,sptr,sptr,sptr
	#func global midiOutPrepareHeader "midiOutPrepareHeader" sptr,sptr,sptr
	#func global midiOutReset "midiOutReset" sptr
	#func global midiOutSetVolume "midiOutSetVolume" sptr,sptr
	#func global midiOutShortMsg "midiOutShortMsg" sptr,sptr
	#func global midiOutUnprepareHeader "midiOutUnprepareHeader" sptr,sptr,sptr
	#func global midiStreamClose "midiStreamClose" sptr
	#func global midiStreamOpen "midiStreamOpen" sptr,sptr,sptr,sptr,sptr,sptr
	#func global midiStreamOut "midiStreamOut" sptr,sptr,sptr
	#func global midiStreamPause "midiStreamPause" sptr
	#func global midiStreamPosition "midiStreamPosition" sptr,sptr,sptr
	#func global midiStreamProperty "midiStreamProperty" sptr,sptr,sptr
	#func global midiStreamRestart "midiStreamRestart" sptr
	#func global midiStreamStop "midiStreamStop" sptr
	#func global mixerClose "mixerClose" sptr
	#define global mixerGetControlDetails mixerGetControlDetailsA
	#func global mixerGetControlDetailsA "mixerGetControlDetailsA" sptr,sptr,sptr
	#func global mixerGetControlDetailsW "mixerGetControlDetailsW" wptr,wptr,wptr
	#define global mixerGetDevCaps mixerGetDevCapsA
	#func global mixerGetDevCapsA "mixerGetDevCapsA" sptr,sptr,sptr
	#func global mixerGetDevCapsW "mixerGetDevCapsW" wptr,wptr,wptr
	#func global mixerGetID "mixerGetID" sptr,sptr,sptr
	#define global mixerGetLineControls mixerGetLineControlsA
	#func global mixerGetLineControlsA "mixerGetLineControlsA" sptr,sptr,sptr
	#func global mixerGetLineControlsW "mixerGetLineControlsW" wptr,wptr,wptr
	#define global mixerGetLineInfo mixerGetLineInfoA
	#func global mixerGetLineInfoA "mixerGetLineInfoA" sptr,sptr,sptr
	#func global mixerGetLineInfoW "mixerGetLineInfoW" wptr,wptr,wptr
	#func global mixerGetNumDevs "mixerGetNumDevs"
	#func global mixerMessage "mixerMessage" sptr,sptr,sptr,sptr
	#func global mixerOpen "mixerOpen" sptr,sptr,sptr,sptr,sptr
	#func global mixerSetControlDetails "mixerSetControlDetails" sptr,sptr,sptr
	#func global mmDrvInstall "mmDrvInstall" sptr,sptr,sptr,sptr
	#func global mmGetCurrentTask "mmGetCurrentTask"
	#func global mmTaskBlock "mmTaskBlock" sptr
	#func global mmTaskCreate "mmTaskCreate" sptr,sptr,sptr
	#func global mmTaskSignal "mmTaskSignal" sptr
	#func global mmTaskYield "mmTaskYield"
	#func global mmioAdvance "mmioAdvance" sptr,sptr,sptr
	#func global mmioAscend "mmioAscend" sptr,sptr,sptr
	#func global mmioClose "mmioClose" sptr,sptr
	#func global mmioCreateChunk "mmioCreateChunk" sptr,sptr,sptr
	#func global mmioDescend "mmioDescend" sptr,sptr,sptr,sptr
	#func global mmioFlush "mmioFlush" sptr,sptr
	#func global mmioGetInfo "mmioGetInfo" sptr,sptr,sptr
	#define global mmioInstallIOProc mmioInstallIOProcA
	#func global mmioInstallIOProcA "mmioInstallIOProcA" sptr,sptr,sptr
	#func global mmioInstallIOProcW "mmioInstallIOProcW" wptr,wptr,wptr
	#define global mmioOpen mmioOpenA
	#func global mmioOpenA "mmioOpenA" sptr,sptr,sptr
	#func global mmioOpenW "mmioOpenW" wptr,wptr,wptr
	#func global mmioRead "mmioRead" sptr,sptr,sptr
	#define global mmioRename mmioRenameA
	#func global mmioRenameA "mmioRenameA" sptr,sptr,sptr,sptr
	#func global mmioRenameW "mmioRenameW" wptr,wptr,wptr,wptr
	#func global mmioSeek "mmioSeek" sptr,sptr,sptr
	#func global mmioSendMessage "mmioSendMessage" sptr,sptr,sptr,sptr
	#func global mmioSetBuffer "mmioSetBuffer" sptr,sptr,sptr,sptr
	#func global mmioSetInfo "mmioSetInfo" sptr,sptr,sptr
	#define global mmioStringToFOURCC mmioStringToFOURCCA
	#func global mmioStringToFOURCCA "mmioStringToFOURCCA" sptr,sptr
	#func global mmioStringToFOURCCW "mmioStringToFOURCCW" wptr,wptr
	#func global mmioWrite "mmioWrite" sptr,sptr,sptr
	#func global mmsystemGetVersion "mmsystemGetVersion"
	#func global mod32Message "mod32Message" sptr,sptr,sptr,sptr,sptr
	#func global mxd32Message "mxd32Message" sptr,sptr,sptr,sptr,sptr
	#define global sndPlaySound sndPlaySoundA
	#func global sndPlaySoundA "sndPlaySoundA" sptr,sptr
	#func global sndPlaySoundW "sndPlaySoundW" wptr,wptr
	#func global tid32Message "tid32Message" sptr,sptr,sptr,sptr,sptr
	#func global timeBeginPeriod "timeBeginPeriod" sptr
	#func global timeEndPeriod "timeEndPeriod" sptr
	#func global timeGetDevCaps "timeGetDevCaps" sptr,sptr
	#func global timeGetSystemTime "timeGetSystemTime" sptr,sptr
	#func global timeGetTime "timeGetTime"
	#func global timeKillEvent "timeKillEvent" sptr
	#func global timeSetEvent "timeSetEvent" sptr,sptr,sptr,sptr,sptr
	#func global waveInAddBuffer "waveInAddBuffer" sptr,sptr,sptr
	#func global waveInClose "waveInClose" sptr
	#define global waveInGetDevCaps waveInGetDevCapsA
	#func global waveInGetDevCapsA "waveInGetDevCapsA" sptr,sptr,sptr
	#func global waveInGetDevCapsW "waveInGetDevCapsW" wptr,wptr,wptr
	#define global waveInGetErrorText waveInGetErrorTextA
	#func global waveInGetErrorTextA "waveInGetErrorTextA" sptr,sptr,sptr
	#func global waveInGetErrorTextW "waveInGetErrorTextW" wptr,wptr,wptr
	#func global waveInGetID "waveInGetID" sptr,sptr
	#func global waveInGetNumDevs "waveInGetNumDevs"
	#func global waveInGetPosition "waveInGetPosition" sptr,sptr,sptr
	#func global waveInMessage "waveInMessage" sptr,sptr,sptr,sptr
	#func global waveInOpen "waveInOpen" sptr,sptr,sptr,sptr,sptr,sptr
	#func global waveInPrepareHeader "waveInPrepareHeader" sptr,sptr,sptr
	#func global waveInReset "waveInReset" sptr
	#func global waveInStart "waveInStart" sptr
	#func global waveInStop "waveInStop" sptr
	#func global waveInUnprepareHeader "waveInUnprepareHeader" sptr,sptr,sptr
	#func global waveOutBreakLoop "waveOutBreakLoop" sptr
	#func global waveOutClose "waveOutClose" sptr
	#define global waveOutGetDevCaps waveOutGetDevCapsA
	#func global waveOutGetDevCapsA "waveOutGetDevCapsA" sptr,sptr,sptr
	#func global waveOutGetDevCapsW "waveOutGetDevCapsW" wptr,wptr,wptr
	#define global waveOutGetErrorText waveOutGetErrorTextA
	#func global waveOutGetErrorTextA "waveOutGetErrorTextA" sptr,sptr,sptr
	#func global waveOutGetErrorTextW "waveOutGetErrorTextW" wptr,wptr,wptr
	#func global waveOutGetID "waveOutGetID" sptr,sptr
	#func global waveOutGetNumDevs "waveOutGetNumDevs"
	#func global waveOutGetPitch "waveOutGetPitch" sptr,sptr
	#func global waveOutGetPlaybackRate "waveOutGetPlaybackRate" sptr,sptr
	#func global waveOutGetPosition "waveOutGetPosition" sptr,sptr,sptr
	#func global waveOutGetVolume "waveOutGetVolume" sptr,sptr
	#func global waveOutMessage "waveOutMessage" sptr,sptr,sptr,sptr
	#func global waveOutOpen "waveOutOpen" sptr,sptr,sptr,sptr,sptr,sptr
	#func global waveOutPause "waveOutPause" sptr
	#func global waveOutPrepareHeader "waveOutPrepareHeader" sptr,sptr,sptr
	#func global waveOutReset "waveOutReset" sptr
	#func global waveOutRestart "waveOutRestart" sptr
	#func global waveOutSetPitch "waveOutSetPitch" sptr,sptr
	#func global waveOutSetPlaybackRate "waveOutSetPlaybackRate" sptr,sptr
	#func global waveOutSetVolume "waveOutSetVolume" sptr,sptr
	#func global waveOutUnprepareHeader "waveOutUnprepareHeader" sptr,sptr,sptr
	#func global waveOutWrite "waveOutWrite" sptr,sptr,sptr
	#func global wid32Message "wid32Message" sptr,sptr,sptr,sptr,sptr
	#func global winmmDbgOut "winmmDbgOut" sptr,sptr,sptr,sptr,sptr,sptr,sptr,sptr,sptr,sptr,sptr,sptr,sptr,sptr,sptr,sptr
	#func global winmmSetDebugLevel "winmmSetDebugLevel" sptr
	#func global wod32Message "wod32Message" sptr,sptr,sptr,sptr,sptr
#endif
#endif

#module _WAVEOUT_M_

// 
// モジュール初期化
// 
#deffunc local init

// WAVEFORMATEX 構造体
wBytesPerSample = 2      // 量子化バイト数

wFormatTag      = 0x0001 // WAVE_FORMAT_PCM
nChannels       = 2      // ステレオ
nSamplesPerSec  = 44100  // サンプルレート
wBitsPerSample  = wBytesPerSample * 8
nBlockAlign     = nChannels * wBytesPerSample
nAvgBytesPerSec = nSamplesPerSec * nBlockAlign
cbSize          = 0

wfex = wFormatTag | (nChannels << 16), nSamplesPerSec, nAvgBytesPerSec, nBlockAlign | (wBitsPerSample << 16), cbSize

// オープン
hWaveOut = 0
waveOutOpen varptr(hWaveOut), -1, varptr(wfex), 0, 0, 0 // WAVE_MAPPER, CALLBACK_NULL

return

// 
// モジュール終了処理
// 
#deffunc exit onexit

// クローズ
waveOutReset hWaveOut
waveOutUnprepareHeader hWaveOut, varptr(whdr), 32 // sizeof(WAVEHDR)
waveOutClose hWaveOut

return

// 
// wave 出力
// 
// _wave      : 波形データの入った変数
// _nAvgBytes : 波形データのバイト数
// 
#deffunc waveOut var _wave, int _nAvgBytes

// WAVEHDR 構造体
lpData          = varptr(_wave)
dwBufferLength  = _nAvgBytes
dwBytesRecorded = 0
dwUser          = 0
dwFlags         = 12 // WHDR_BEGINLOOP | WHDR_ENDLOOP
//dwLoops         = 1  // ループ回数
dwLoops         = -1  // ループ回数
lpNext          = 0
reserved        = 0

whdr = lpData, dwBufferLength, dwBytesRecorded, dwUser, dwFlags, dwLoops, lpNext, reserved

// 再生

waveOutReset hWaveOut
waveOutPrepareHeader hWaveOut, varptr(whdr), 32 // sizeof(WAVEHDR)
waveOutWrite hWaveOut, varptr(whdr), 32 // sizeof(WAVEHDR)
return

// 
// サイン波出力
// 
// f : 周波数 (ヘルツ単位)
// a : 振幅   (0.0 〜 1.0)
// t : 時間   (秒単位)
// 
#deffunc waveOutSine double f, double a, double t

// 波形データ
nSamples = int(t * nSamplesPerSec) // 全体のサンプル数
nAvgBytes = nSamples * nBlockAlign // 全体のバイト数

dim wave, (nAvgBytes + 3) / 4
repeat nSamples
// この部分は nChannels や wBytesPerSample によって書き換えが必要
wpoke wave, cnt * 4    , int(sin(2.0 * M_PI * f * cnt / nSamplesPerSec) * 0x7FFF * a) & 0xFFFF
wpoke wave, cnt * 4 + 2, int(sin(2.0 * M_PI * f * cnt / nSamplesPerSec) * 0x7FFF * a) & 0xFFFF
loop

// 再生
waveOut wave, nAvgBytes

return

#global

init@_WAVEOUT_M_

#endif

;============================================================
; ドキュメンテーションコメントつきヘッダファイル
;============================================================
/* 〜 モジュール情報 (hs デフォルトレコード)
%dll
mod_beep

%ver
1.00

%date
2016/07/17

%author
GENKI

%note
mod_beep.hsp をインクルードする。

%type
ユーザー拡張命令

%*/ ; <--- これ以降は hs ファイルとしてはコメントになる
;------------------------------------------------------------

;
;
;[ Update history ]
;yyyy/mm/dd : ver  : comment
;2016/07/17 : 1.00 : 完成
;
;
;
#ifndef __BEEP_MOD__
#define global __BEEP_MOD__

;#include "winmm.as"

#module _MOD_BEEP_
;---------------------------------------------------------------------------------------------------

;///////////////////////////////////////////////////////////////////////////////////////////////////
;
;	定数の定義
;
;#const global 
;#enum global 
#define WAVE_MAPPER     0xFFFFFFFF	// 特にデバイスの区別を意識しないでオープンしたい場合
#define CALLBACK_NULL   0x00000000	// コールバック機構はありません。
#define CALLBACK_WINDOW 0x00010000	// dwCallback パラメータは、ウィンドウハンドルです。

;WAVEHDR 構造体 dwFlags
#define WHDR_DONE       0x00000001  // このフラグはデバイスドライバが設定する。ドライバがバッファの使用を終了したことを表す
#define WHDR_PREPARED   0x00000002  // このフラグは Windows が設定する。バッファが準備されたことを表す
#define WHDR_BEGINLOOP  0x00000004  // このバッファはループ内の先頭バッファである
#define WHDR_ENDLOOP    0x00000008  // このバッファはループ内の最後のバッファである
#define WHDR_INQUEUE    0x00000010  // このフラグは Windows が設定する。バッファが再生キューに入ることを表す

;===========================================================
;
;	init@_MOD_BEEP_
;
;モジュール初期化
;
;===========================================================
/*
BeepInit@_WAVEOUT_M_
モジュール初期化

この命令はモジュール読み込み時に自動的に実行されるため、
ユーザーが実行する必要はありません。

%*/
;------------------------------------------------------------
;

#deffunc local BeepInit
	;-----------------------------------
	;	WAVEFORMATEX 構造体
	;-----------------------------------
	wBytesPerSample = 2      // 量子化バイト数

	wFormatTag      = 0x0001 // WAVE_FORMAT_PCM
	nChannels       = 2      // チャンネル数 [ch]
	nSamplesPerSec  = 44100  // サンプルレート [Hz]
	wBitsPerSample  = wBytesPerSample * 8			// 1 サンプルあたりの量子化ビット数 [byte]
	nBlockAlign     = nChannels * wBytesPerSample	// 1データ分のブロックサイズ [byte]
	nAvgBytesPerSec = nSamplesPerSec * nBlockAlign	// 平均データレート [byte/sec]
	cbSize          = 0

	dim wfex, 5
	wfex(0) = wFormatTag | (nChannels << 16)
	wfex(1) = nSamplesPerSec
	wfex(2) = nAvgBytesPerSec
	wfex(3) = nBlockAlign | (wBitsPerSample << 16)
	wfex(4) = cbSize

	;-----------------------------------
	;	デバイスオープン
	;-----------------------------------
	hWaveOut = 0
	waveOutOpen varptr(hWaveOut), -1, varptr(wfex), 0, 0, 0 // WAVE_MAPPER, CALLBACK_NULL
	
	;-----------------------------------
	;	メモリ確保
	;-----------------------------------
	nAvgBytes = nAvgBytesPerSec		; 1秒分のバッファ
	dim wave_s,  (nAvgBytes + 3) / 4	; 1秒分のバイト数を確保
	dim wave_ms, (nAvgBytes + 3) / 4	; 1ミリ秒分のバイト数を確保
		;nAvgBytesバイト確保。dimは1のとき4byte確保するので1/4倍を指定している。
	dim wave2_s,  (nAvgBytes + 3) / 4	; 1秒分のバイト数を確保
	dim wave2_ms, (nAvgBytes + 3) / 4	; 1ミリ秒分のバイト数を確保

	;-----------------------------------
	;	WAVEHDR 構造体
	;-----------------------------------
	dim whdr_s, 8
	dim whdr_ms, 8
	dim whdr2_s, 8
	dim whdr2_ms, 8

	;	振幅
	ampBeep = 0.4
	return



;===========================================================
/*
%index
BeepExit
Beepモジュール終了処理

%inst
Beepモジュールの終了処理を行います。
終了時に自動実行されるためユーザーが直接実行する必要はありません。

%group
マルチメディア制御命令

%*/
;------------------------------------------------------------
;
#deffunc BeepExit onexit

	// クローズ
	waveOutReset hWaveOut
	;	WAVEHDR 構造体を使用中の場合、一旦開放。
	if whdr_s(4) & WHDR_PREPARED {
		waveOutUnprepareHeader hWaveOut, varptr(whdr_s), 32 // sizeof(WAVEHDR)
	}
	if whdr_ms(4) & WHDR_PREPARED {
		waveOutUnprepareHeader hWaveOut, varptr(whdr_ms), 32 // sizeof(WAVEHDR)
	}
	if whdr2_s(4) & WHDR_PREPARED {
		waveOutUnprepareHeader hWaveOut, varptr(whdr2_s), 32 // sizeof(WAVEHDR)
	}
	if whdr2_ms(4) & WHDR_PREPARED {
		waveOutUnprepareHeader hWaveOut, varptr(whdr2_ms), 32 // sizeof(WAVEHDR)
	}
	waveOutClose hWaveOut

	return



;===========================================================
/*
	BeepSetWavehdr@_MOD_BEEP_
	WAVEHDR 構造体を作成
array _whdr     : WAVEHDR 構造体
var   _wave     : 波形バッファ
int   _nAvgBytes: 波形データのバイト数
int   p_loop    : ループ回数

WAVEHDR 構造体を作成します。
p_loopに0以下の値を指定するとループしません。
モジュール内で使用するための関数なので、ユーザーは使用する必要はありません。
*/
;------------------------------------------------------------
;
#deffunc local BeepSetWavehdr array _whdr, var _wave, int _nAvgBytes, int p_loop
	;-----------------------------------
	;	引数チェック
	;-----------------------------------
	loops = p_loop
	if p_loop < 0 : loops = 0
	;if length(_whdr)<8 : dim _whdr, 8
	
	;-----------------------------------
	;	WAVEHDR 構造体
	;-----------------------------------
	lpData          = varptr(_wave)	// 波形バッファへのポインタ。
	dwBufferLength  = _nAvgBytes	// 波形データのバイト数
	dwBytesRecorded = 0				// バッファ内にあるデータの量
	dwUser          = 0				// ユーザーデータ
	dwFlags         = 12 * (loops>0)	// WHDR_BEGINLOOP | WHDR_ENDLOOP
	dwLoops         = loops			// ループ回数
	lpNext          = 0		// 予約
	reserved        = 0		// 予約

	// dwFlags
	// #define WHDR_DONE       0x00000001  // このフラグはデバイスドライバが設定する。ドライバがバッファの使用を終了したことを表す
	// #define WHDR_PREPARED   0x00000002  // このフラグは Windows が設定する。バッファが準備されたことを表す
	// #define WHDR_BEGINLOOP  0x00000004  // このバッファはループ内の先頭バッファである
	// #define WHDR_ENDLOOP    0x00000008  // このバッファはループ内の最後のバッファである
	// #define WHDR_INQUEUE    0x00000010  // このフラグは Windows が設定する。バッファが再生キューに入ることを表す

	_whdr(0) = lpData
	_whdr(1) = dwBufferLength
	_whdr(2) = dwBytesRecorded
	_whdr(3) = dwUser
	_whdr(4) = dwFlags
	_whdr(5) = dwLoops
	_whdr(6) = lpNext
	_whdr(7) = reserved
	return



;===========================================================
/*
%index
BeepSetAmp
Beep音の音量を設定

%prm
amp
double amp =0.0〜1.0(0.4) : 音の大きさ、振幅値

%inst
Beep音の音量（波形の振幅値）を設定します。
0.0〜1.0の値が指定できます。
初期値および省略時は、0.4に設定されます。

%href
BeepPlay

%group
マルチメディア制御命令

%*/
;------------------------------------------------------------
;
#deffunc BeepSetAmp_ double p_amp
	ampBeep = p_amp
	if p_amp < 0.0 : ampBeep = 0.0
	if p_amp > 1.0 : ampBeep = 1.0
	return

#define global BeepSetAmp(%1=0.4)	BeepSetAmp_ %1


	
;===========================================================
/*
%index
BeepPlay
スピーカから単純な音を鳴らします。

%prm
freq, duration
int freq     =0〜 (441): 周波数 [Hz]
int duration =0〜(1000): 時間   [sec]
int standby         (1): 再生終了を確認する間隔 [msec]

%inst
スピーカから単純な音（矩形波）を鳴らします。
昔のPCのビープ音のような音が聞こえます。左右両方のスピーカーから同じ音が出ます。
BeepPlayとBeepPlayの間に無音時間を作りたい場合は、waitやawaitではなく、BeepPlay 0 を
使用してください。

freq
音の周波数をヘルツ単位で指定します。
整数値が指定できます。
0を指定すると無音になります。

duration
音の継続時間をミリ秒（ms）単位で指定します。

standby
0以上の値を指定すると、音声の再生が終了するまで待機します。次の行の命令を実行しません。
再生終了を確認する時間間隔をミリ秒単位で指定します。通常は1以上の値を指定します。
マイナス値(-1など)を指定すると、待機せずに次の行の命令を実行します。
省略すると1が指定されます。

音声の再生を中断して待機を解除したい場合は、BeepStop命令を使用してください。

%sample
; サンプルスクリプト を記入

%href
BeepStop

%group
マルチメディア制御命令

%*/
;------------------------------------------------------------
;
#deffunc BeepPlay_ int p_freq, int p_duration, int p_standby
	
	;-----------------------------------
	;	引数チェック
	;-----------------------------------
	freqSin  = p_freq
	if freqSin<=0 : freqSin = abs(freqSin)
	ampSin   = ampBeep	;振幅
	if freqSin = 0 : ampSin = 0.0
	duration = p_duration
	if duration<=0 : duration = abs(duration)
	;	1秒単位と1000ミリ秒未満の数字に分割
	lenghSinSec_s  = int(duration/1000)			; sec
	lenghSinSec_ms = duration - lenghSinSec_s*1000		; m sec


	;-----------------------------------
	;	WAVEHDR 構造体を使用中の場合、再生を止めて一旦開放。
	;-----------------------------------
	;再生終了を待たない場合
	if (p_standby < 0) {
		waveOutPause hWaveOut
		waveOutReset hWaveOut
		if whdr_s(4) & WHDR_PREPARED {
			waveOutUnprepareHeader hWaveOut, varptr(whdr_s), 32 // sizeof(WAVEHDR)
		}
		if whdr_ms(4) & WHDR_PREPARED {
			waveOutUnprepareHeader hWaveOut, varptr(whdr_ms), 32 // sizeof(WAVEHDR)
		}
		if whdr2_s(4) & WHDR_PREPARED {
			waveOutUnprepareHeader hWaveOut, varptr(whdr2_s), 32 // sizeof(WAVEHDR)
		}
		if whdr2_ms(4) & WHDR_PREPARED {
			waveOutUnprepareHeader hWaveOut, varptr(whdr2_ms), 32 // sizeof(WAVEHDR)
		}
	}


	;-----------------------------------
	;	ウェーブバッファの空きを探す
	;-----------------------------------	
	;バッファは2個しか用意してないので、どっちかがあくまで待機する。
	;正確にはバッファというより、キュー投入されていないバッファを探す。
	
	f1 = whdr_s(4) |whdr_ms(4)  & WHDR_INQUEUE
	f2 = whdr2_s(4)|whdr2_ms(4) & WHDR_INQUEUE

	;	バッファに空きがない場合は待機
	if (p_standby >= 0) & ((f1&f2)!0) {
		;	前の音声の再生が終了するまで待機
		repeat
			f1 = whdr_s(4) |whdr_ms(4)  & WHDR_INQUEUE
			f2 = whdr2_s(4)|whdr2_ms(4) & WHDR_INQUEUE
			if (f1 & f2)=0 : break
			await p_standby
		loop
	}

	;	空いている方のクローンを作成
	;毎回ifで分けて書くのが面倒なので、クローンを使う。
	if f1 = 0 {
		;whdr_s, whdr_ms が空いている
		dup whdr_s_,  whdr_s
		dup whdr_ms_, whdr_ms
		dup wave_s_,  wave_s
		dup wave_ms_, wave_ms
	} else {
		;whdr2_s, whdr2_ms が空いている
		dup whdr_s_,  whdr2_s
		dup whdr_ms_, whdr2_ms
		dup wave_s_,  wave2_s
		dup wave_ms_, wave2_ms
	}
	

	;-----------------------------------
	;	波形データ
	;-----------------------------------
	;サンプル数
	nSamples_s  = nSamplesPerSec * (lenghSinSec_s  > 0)
	nSamples_ms = nSamplesPerSec *  lenghSinSec_ms / 1000
	
	;前の波形データを削除
	memset wave_s_,  0, nAvgBytes
	memset wave_ms_, 0, nAvgBytes

	;波形作成
	repeat nSamples_s
		;正弦波
		;y = int(sin(2.0 * M_PI * freqSin * cnt / nSamplesPerSec) * 0x7FFF * ampSin) & 0xFFFF
		;矩形波
		y = int(double((sin(2.0 * M_PI * freqSin * cnt / nSamplesPerSec)>0.0)*2-1) * 0x7FFF * ampSin) & 0xFFFF
		// 1ch
		wpoke wave_s_, cnt * 4    , y
		// 2ch
		wpoke wave_s_, cnt * 4+2  , y
	loop
	repeat nSamples_ms
		;正弦波
		;y = int(sin(2.0 * M_PI * freqSin * cnt / nSamplesPerSec) * 0x7FFF * ampSin) & 0xFFFF
		;矩形波
		y = int(double((sin(2.0 * M_PI * freqSin * cnt / nSamplesPerSec)>0.0)*2-1) * 0x7FFF * ampSin) & 0xFFFF
		// 1ch
		wpoke wave_ms_, cnt * 4    , y
		// 2ch
		wpoke wave_ms_, cnt * 4+2  , y
	loop

	;-----------------------------------
	;	WAVEHDR 構造体を作成
	;-----------------------------------
	if nSamples_s > 0 {
		BeepSetWavehdr@_MOD_BEEP_ whdr_s_,  wave_s_, nAvgBytes, lenghSinSec_s
	}
	if nSamples_ms > 0 {
		BeepSetWavehdr@_MOD_BEEP_ whdr_ms_, wave_ms_, nSamples_ms * nBlockAlign, 0
	}

	;-----------------------------------
	;	再生
	;-----------------------------------
	;waveOutReset hWaveOut
	if nSamples_s > 0 {
		waveOutPrepareHeader hWaveOut, varptr(whdr_s_), 32 // sizeof(WAVEHDR)
		waveOutWrite         hWaveOut, varptr(whdr_s_), 32 // sizeof(WAVEHDR)
	}
	if nSamples_ms > 0 {
		waveOutPrepareHeader hWaveOut, varptr(whdr_ms_), 32 // sizeof(WAVEHDR)
		waveOutWrite         hWaveOut, varptr(whdr_ms_), 32 // sizeof(WAVEHDR)
	}

	return

#define global BeepPlay(%1=441, %2=1000, %3=1)	BeepPlay_ %1, %2, %3


;===========================================================
/*
%index
BeepIsDone
再生終了確認

%inst
BeepPlay命令で再生中の音声が再生中かどうか調べます。

stat
再生中の場合、0を返します。
全ての音声の再生が終了すると、1を返すようになります。

%sample
BeepPlay 100, 5000, -1
mes "再生中"
;待機
repeat
	BeepIsDone
	if stat : break
	await 1
loop
mes "再生終了"

%href
BeepPlay

%group
マルチメディア制御命令

%*/
;------------------------------------------------------------
;
#deffunc BeepIsDone
	;	WAVEHDR構造体のメンバーdwFlagsをチェックして再生終了を判定
	f = 1
	
	;dwFlagsにWHDR_DONEフラグが立てばバッファは再生終了
	if whdr_s(4) & WHDR_PREPARED {
		f &= whdr_s(4) & WHDR_DONE
	}
	if whdr_ms(4) & WHDR_PREPARED {
		f &= whdr_ms(4) & WHDR_DONE
	}
	if whdr2_s(4) & WHDR_PREPARED {
		f &= whdr2_s(4) & WHDR_DONE
	}
	if whdr2_ms(4) & WHDR_PREPARED {
		f &= whdr2_ms(4) & WHDR_DONE
	}

	return f


;===========================================================
/*
%index
BeepWaitPlayend
再生が終了するまで待機。

%prm
standby
int standby (1): 再生終了を確認する間隔 [msec]

%inst
BeepPlayでの音声再生が終了するまで待機します。
standbyで指定した時間間隔おきに周期的に再生が終了したかどうかを確認します。
マイナス値を指定すると何もせず終了します。

%sample
BeepPlay 100, 5000, -1
mes "再生中"
;待機
BeepWaitPlayend 1
mes "再生終了"

%href
BeepIsDone

%group
マルチメディア制御命令

%*/
;------------------------------------------------------------
;
#deffunc BeepWaitPlayend_ int p_standby
	if p_standby<0 : return

	;	再生終了まで待機
	repeat
		BeepIsDone
		if stat : break
		await p_standby
	loop
	return

#define global BeepWaitPlayend(%1=1) BeepWaitPlayend_ %1




;===========================================================
/*
%index
BeepPause
一時停止

%inst
再生中のBeep音を一時停止します。
BeepRestartで再生を再開することが出来ます。

%href
BeepRestart

%group
マルチメディア制御命令

%*/
;------------------------------------------------------------
;
#deffunc BeepPause
	waveOutPause hWaveOut
	return


;===========================================================
/*
%index
BeepRestart
再生を再開

%inst
BeepPauseで一時停止したBeep音の再生を再開します。

%href
BeepRestart

%group
マルチメディア制御命令

%*/
;------------------------------------------------------------
;
#deffunc BeepRestart
	waveOutRestart hWaveOut
	return


;===========================================================
/*
%index
BeepStop
停止

%inst
BeepPlayで再生している音の再生を終了します。
現在の音の再生を終了すると、直ちに次のBeepPlayの音の再生を開始します。

%href
BeepPlay

%group
マルチメディア制御命令

%*/
;------------------------------------------------------------
;
#deffunc BeepStop
	waveOutPause hWaveOut
	waveOutReset hWaveOut

	;-----------------------------------
	;	クローズ
	;-----------------------------------
	;	WAVEHDR 構造体を使用中の場合、一旦開放。
	if whdr_s(4) & WHDR_PREPARED {
		waveOutUnprepareHeader hWaveOut, varptr(whdr_s), 32 // sizeof(WAVEHDR)
	}
	if whdr_ms(4) & WHDR_PREPARED {
		waveOutUnprepareHeader hWaveOut, varptr(whdr_ms), 32 // sizeof(WAVEHDR)
	}
	return

#global	;_MOD_BEEP_

BeepInit@_MOD_BEEP_

#endif	;__MOD_BEEP__



;-------------------------------------------------------------------------------
;
;	サンプルスクリプト
;

;#####################################################################
;ここを有効にするとこのファイル単独での実行が可能になります。
;
;0	：リリースモード　本体側から#includeで連結して動作させる場合です。
;1	：デバッグモード　このファイル単品で動作確認が出来ます。
#if 0


button goto "＞再生", *l_play
button gosub "■停止", *l_stop
button gosub "||一時停止", *l_pause
button gosub "＞再開", *l_restart
button goto "♪ド", *l_play_do
button goto "♪レ", *l_play_re

gosub *l_play

stop


;-----------------------------------
;	再生
;-----------------------------------
*l_play
	mes "再生中"
	t = 250
	BeepPlay 262, t	; ド
	BeepPlay 294, t	; レ
	BeepPlay 330, t	; ミ
	BeepPlay 349, t	; ファ
	BeepPlay 392, t	; ソ
	BeepPlay 440, t	; ラ
	BeepPlay 494, t	; シ
	BeepPlay 523, t	; ド（高音）
	BeepPlay 0, t	; 無音
	BeepPlay 262, t	; ド
	BeepPlay 294, t*2	; レー
	BeepPlay 330, t*3	; ミーー
	
;	再生終了まで待機
	repeat
		BeepIsDone
		if stat : break
		await 1
	loop
	mes "再生終了"
	stop


;-----------------------------------
;	停止
;-----------------------------------
*l_stop
	BeepStop
	return


;-----------------------------------
;	一時停止
;-----------------------------------
*l_pause
	BeepPause
	return


;-----------------------------------
;	一時停止解除
;-----------------------------------
*l_restart
	BeepRestart
	return

;-----------------------------------
;	簡易鍵盤：待たずに再生
;-----------------------------------
*l_play_do
	t = 1000
	BeepPlay 262, t, -1	; ド
	stop

*l_play_re
	BeepPlay 294, t, -1	; レ
	stop
	
#endif
;#####################################################################



bgscr 0,ginfo(20),ginfo(21),0,0,0
//hgini
title "Gocaine N80"
mwxs=ginfo(26)
mwys=ginfo(27)
cls 4
z80hltendset 0,2
repeat 255:z80hltendset (cnt+1),2:loop
dim rtctimetmp,6
dim rtctime,6
dim rtctimeforminus,5
rtctimeforminus(0)=0
rtctimeforminus(1)=0
rtctimeforminus(2)=0
rtctimeforminus(3)=0
rtctimeforminus(4)=0
dim keyio,16
dim keymap,256
repeat 256:keymap(cnt)=0xFF:loop
keymap(96)=0x00
keymap(97)=0x01
keymap(98)=0x02
keymap(99)=0x03
keymap(100)=0x04
keymap(101)=0x05
keymap(102)=0x06
keymap(103)=0x07

keymap(104)=0x10
keymap(105)=0x11
keymap(106)=0x12
keymap(107)=0x13
keymap(108)=0x14
keymap(109)=0x15
keymap(46)=0x16
keymap(13)=0x17

keymap(192)=0x20
keymap(65)=0x21
keymap(66)=0x22
keymap(67)=0x23
keymap(68)=0x24
keymap(69)=0x25
keymap(70)=0x26
keymap(71)=0x27

keymap(72)=0x30
keymap(73)=0x31
keymap(74)=0x32
keymap(75)=0x33
keymap(76)=0x34
keymap(77)=0x35
keymap(78)=0x36
keymap(79)=0x37

keymap(80)=0x40
keymap(81)=0x41
keymap(82)=0x42
keymap(83)=0x43
keymap(84)=0x44
keymap(85)=0x45
keymap(86)=0x46
keymap(87)=0x47

keymap(88)=0x50
keymap(89)=0x51
keymap(90)=0x52
keymap(219)=0x53
keymap(220)=0x54
keymap(221)=0x55
keymap(222)=0x56
keymap(189)=0x57

keymap(48)=0x60
keymap(49)=0x61
keymap(50)=0x62
keymap(51)=0x63
keymap(52)=0x64
keymap(53)=0x65
keymap(54)=0x66
keymap(55)=0x67

keymap(56)=0x70
keymap(57)=0x71
keymap(186)=0x72
keymap(187)=0x73
keymap(188)=0x74
keymap(190)=0x75
keymap(191)=0x76
keymap(226)=0x77

keymap(36)=0x80
keymap(38)=0x81
keymap(39)=0x82
keymap(8)=0x83
keymap(18)=0x84
keymap(229)=0x85
keymap(16)=0x86
keymap(17)=0x87

keymap(93)=0x84
keymap(29)=0x85

keymap(35)=0x90
keymap(112)=0x91
keymap(113)=0x92
keymap(114)=0x93
keymap(115)=0x94
keymap(116)=0x95
keymap(32)=0x96
keymap(27)=0x97

/*keymap(40)=0xb2
keymap(37)=0xb3*/
keymap(40)=0x81
keymap(37)=0x82

rxdatareadey=0
upd8251config=0
cmtdatard=0
cmtdatawr=0
cassettemtstate=0
cmtbinsnd=0
fddconnected=0
uipin=0
uopout=0
pch=0
grpbfsetting=0
crtc2=0
crtc3=0
rommode=0
graphicdraw=0
romtype=0
grpmode=0
colorgraphicmode=0
bgcolor=0
bankid=0
prtenable=0
vramaddr=0
othercrtcio=0
scanlinetype=0
useoldrender=0
exsbaddr=0
exsbaddr2=0
unusedaddr=0
vramaddrtc=0
exsbaddrtc=0
exsbaddr2tc=0
unusedaddrtc=0
upd31speclzsig=0
litepeninp=0
upd3301stat=224
usejit=0
fc_ptabcmode=0
fc_portabcrw=0
fc_bsrmode=0
fc_i8255view=0
i8255md1sigbufa=0
i8255md1sigbufb=0
beepenabletimex=1000
sdim memory,65536
sdim fontrom,0x800
sdim rom,65536,16
sdim exrom,65536,2
upd8251configate=0

dim cassettestateptr,256
cassettestateptr(0)=varptr(cmtdatard),varptr(cmtdatawr),varptr(cassettemtstate),varptr(cmtbinsnd),varptr(fddconnected),varptr(prtready),varptr(uipin),varptr(uopout),varptr(pch),varptr(grpbfsetting),varptr(crtc2),varptr(crtc3),varptr(rommode),varptr(graphicdraw),varptr(romtype),varptr(grpmode),varptr(colorgraphicmode),varptr(bgcolor),varptr(bankid),varptr(memory),varptr(fontrom),varptr(rom),varptr(exrom(0)),varptr(exrom(1)),varptr(upd8251config),varptr(rxdatareadey),varptr(prtenable),varptr(vramaddr),varptr(othercrtcio),varptr(upd3301cmd),varptr(upd3301prm),varptr(scanlinetype),varptr(useoldrender),varptr(exsbaddr),varptr(exsbaddr2),varptr(vramaddr),varptr(unusedaddr),varptr(exsbaddrtc),varptr(exsbaddr2tc),varptr(vramaddrtc),varptr(unusedaddrtc),varptr(upd31speclzsig),varptr(litepeninp),varptr(upd3301stat),varptr(usejit),varptr(oaearchptr),varptr(oae),varptr(fc_ptabcmode),varptr(fc_portabcrw),varptr(fc_bsrmode),varptr(fc_i8255view),varptr(i8255md1sigbufa),varptr(i8255md1sigbufb)

volhz=2400
sdim wavdata,(volhz)*100+4*11//0x0158AC*2+8
lpoke wavdata,4*0,0x46464952
lpoke wavdata,4*1,varsize(wavdata)-8
lpoke wavdata,4*2,0x45564157
lpoke wavdata,4*3,0x20746D66
lpoke wavdata,4*4,16
wpoke wavdata,4*5+2*0,1
wpoke wavdata,4*5+2*1,1
lpoke wavdata,4*6,(volhz)//0xAC44
wpoke wavdata,4*8+2*1,8
lpoke wavdata,4*9,0x61746164
lpoke wavdata,4*10,varsize(wavdata)-44
lpoke wavdata,4*7,lpeek(wavdata,4*6)*(wpeek(wavdata,4*8+2*1)/8)*wpeek(wavdata,4*5+2*1)
mes lpeek(wavdata,4*6)*(wpeek(wavdata,4*8+2*1)/8)*wpeek(wavdata,4*5+2*1)
wpoke wavdata,4*8+2*0,(wpeek(wavdata,4*8+2*1)/8)*wpeek(wavdata,4*5+2*1)
wavs=0
repeat ((varsize(wavdata)-4*11)/4)
wavs+=50:if wavs>=100{wavs=30}
wpoke wavdata,4*11+cnt*2,0x6000//|rnd(45)//0x7fff
loop
memfile wavdata,0,varsize(wavdata)
mmload "MEM:a.wav",0,1

oncmd gosub *keydown,$100
oncmd gosub *keyup,$101
oncmd gosub *clkdownmvup,0x200
oncmd gosub *clkdownmvup,0x201
oncmd gosub *clkdownmvup,0x202
onclick gosub *clkdownmvup
oncmd gosub *interruptlbl,$113
buffer 1,640,200,1
palcolor 0:boxf
repeat 8
palette cnt,((cnt>>1)&0x01)*255,((cnt>>2)&0x01)*255,((cnt>>0)&0x01)*255,(cnt=7)
loop
repeat 8
palette cnt+0x10,((cnt>>1)&0x01)*230,((cnt>>2)&0x01)*230,((cnt>>0)&0x01)*230,(cnt=7)
loop
repeat 8
palette cnt+0x20,((cnt>>1)&0x01)*255,((cnt>>2)&0x01)*255,((cnt>>0)&0x01)*255,(cnt=7)
loop
repeat 8
palette cnt+0x30,((cnt>>1)&0x01)*230,((cnt>>2)&0x01)*230,((cnt>>0)&0x01)*230,(cnt=7)
loop
palette 8,0,0,0,0
palette 9,255,255,255,0
palette 8+0x10,0,0,0,0
palette 9+0x10,230,230,230,0
palette 10,0,0,0,1
mref vram600,66
dupptr vram600lst,varptr(vram600)+varsize(vram600)-0x800,0x800,2
buffer 2,320,200,1
gsel 2,0
repeat 8
if cnt=3 or cnt=7{palette cnt,0,0,0,(cnt=7)}else{palette cnt,((cnt>>0)&0x01)*255,((cnt>>1)&0x01)*255,((cnt>>2)&0x01)*255,(cnt=7)}
loop
repeat 8
if cnt=3 or cnt=7{palette cnt+0x10,0,0,0,(cnt=7)}else{palette cnt+0x10,((cnt>>0)&0x01)*230,((cnt>>1)&0x01)*230,((cnt>>2)&0x01)*230,(cnt=7)}
loop
repeat 8
palette cnt+0x20,((cnt>>1)&0x01)*255,((cnt>>2)&0x01)*255,((cnt>>0)&0x01)*255,(cnt=7)
loop
repeat 8
palette cnt+0x30,((cnt>>1)&0x01)*230,((cnt>>2)&0x01)*230,((cnt>>0)&0x01)*230,(cnt=7)
loop
palette 8,0,0,0,0
palette 9,255,255,255,0
palette 8+0x10,0,0,0,0
palette 9+0x10,230,230,230,0
palette 10,0,0,0,1
buffer 3,640,480
bgscr 5,1280,768,0,0,0
gsel 5,0
hgini
settingwindowhwnd2=hwnd
gsel 5,-1
buffer 3,640,400
buffer 6,640,400
bgscr 4,mwxs,mwys,0,0,0
gsel 4,0
settingwindowhwnd=hwnd
enckey(0)=759386183,825241656

readmemesint(0)=5041,8880,6633,4365
readmemesint(4)=5880,5280,4848,1568
readmemesint(8)=5538,4480,3216,1440
readmemesint(12)=2240,3216,5328,4900
readmemesint(16)=7171,8800,6499,4905
readmemesint(20)=5656,2784,3600,5145
readmemesint(24)=8165,8560,6499,4950
readmemesint(28)=2520,3648,4848,5880
readmemesint(32)=7455,7920,7437,4950
readmemesint(36)=3696,5472,5040,4851
readmemesint(40)=7597,9200,2747,585
readmemesint(44)=560,4032,4992,5145
readmemesint(48)=8165,2560,7705,4995
readmemesint(52)=5712,5568,5712,4753
readmemesint(56)=8094,8080,2144,4725
readmemesint(60)=6440,1536,5616,5390
readmemesint(64)=7668,8400,6633,4545
readmemesint(68)=6160,5520,4848,4900
readmemesint(72)=3124,7840,7839,5220
readmemesint(76)=1792,5808,5328,5733
readmemesint(80)=2272,8320,6499,5310
readmemesint(84)=5656,1536,5568,5439
readmemesint(88)=2272,8960,7638,4545
readmemesint(92)=6272,4656,5472,4949
readmemesint(96)=2272,9280,6968,4545
readmemesint(100)=1792,4704,5040,5439
readmemesint(104)=8165,2560,6499,4950
readmemesint(108)=5600,1536,4896,5439
readmemesint(112)=7810,9280,7705,1485
readmemesint(116)=728,480,5568,5096
readmemesint(120)=7171,2560,6566,4725
readmemesint(124)=6216,5520,1536,4998
readmemesint(128)=7455,8640,6767,4950
readmemesint(132)=5432,5232,4848,1568
readmemesint(136)=7739,9360,7705,5220
readmemesint(140)=1792,4704,4848,1568
readmemesint(144)=2414,8800,3752,2160
readmemesint(148)=5488,4656,5520,5145
readmemesint(152)=7029,3680,7638,4995
readmemesint(156)=6104,1632,624,490
readmemesint(160)=8236,8320,6767,1440
readmemesint(164)=5712,5328,5280,5684
readmemesint(168)=2272,8160,7035,4860
readmemesint(172)=5656,5280,4656,5341
readmemesint(176)=7171,2560,7303,5265
readmemesint(180)=6440,5568,1536,4802
readmemesint(184)=7171,2560,2278,4590
readmemesint(188)=6216,5280,5568,2254
readmemesint(192)=8094,8880,7303,1530
readmemesint(196)=728,480,4176,5096
readmemesint(200)=8591,2560,7772,4680
readmemesint(204)=5656,1536,5520,5439
readmemesint(208)=7242,9280,7973,4365
readmemesint(212)=6384,4848,1536,5145
readmemesint(216)=8165,2560,7504,5130
readmemesint(220)=6216,5664,5040,4900
readmemesint(224)=7171,8000,2144,5265
readmemesint(228)=6160,4800,4848,5586
readmemesint(232)=2272,9360,7370,4860
readmemesint(236)=5880,4752,4848,5390
readmemesint(240)=8165,8080,6700,1485
readmemesint(244)=728,480,3168,4949
readmemesint(248)=7029,7760,7839,5175
readmemesint(252)=5656,1536,5040,5390
readmemesint(256)=7455,9280,7035,4365
readmemesint(260)=6048,1536,3504,2254
readmemesint(264)=5893,3680,2144,4500
readmemesint(268)=6216,1536,5232,4949
readmemesint(272)=2272,7760,2144,4680
readmemesint(276)=5432,5472,5232,1568
readmemesint(280)=8236,8880,2144,4725
readmemesint(284)=6272,1536,4704,5733
readmemesint(288)=8165,9680,7370,4545
readmemesint(292)=6440,5520,5040,5390
readmemesint(296)=7313,2640,871,450
readmemesint(300)=4648,5328,1536,3577
readmemesint(304)=2272,8320,6499,5310
readmemesint(308)=5656,1536,5664,4949
readmemesint(312)=8094,9680,2144,4905
readmemesint(316)=6552,4752,4992,1568
readmemesint(320)=8236,9120,6499,5265
readmemesint(324)=6104,4656,5568,5145
readmemesint(328)=7029,2560,6767,5400
readmemesint(332)=6272,4848,5472,5145
readmemesint(336)=7171,8800,6633,4545
readmemesint(340)=1792,5040,5280,1568
readmemesint(344)=8236,8320,6767,1440
readmemesint(348)=5488,5616,5520,5929
readmemesint(352)=7810,8080,7705,5175
readmemesint(356)=5880,5280,4944,1617
readmemesint(360)=923,800,4891,5220
readmemesint(364)=1792,5232,4848,4753
readmemesint(368)=7810,8400,7370,4635
readmemesint(372)=1792,5568,4992,4753
readmemesint(376)=8236,2560,4891,1440
readmemesint(380)=5544,4656,5280,5390
readmemesint(384)=7881,9280,2144,4410
readmemesint(388)=6552,5520,5808,5390
readmemesint(392)=7171,9200,7705,4725
readmemesint(396)=6160,4944,1536,5831
readmemesint(400)=7455,9280,6968,1440
readmemesint(404)=6048,5040,5136,4949
readmemesint(408)=2272,8960,6499,5220
readmemesint(412)=5656,5280,5568,5635
readmemesint(416)=3124,2560,7772,5130
readmemesint(420)=5432,4800,4848,5341
readmemesint(424)=6887,9120,7169,5175
readmemesint(428)=1792,4656,5280,4900
readmemesint(432)=2272,7760,7370,5445
readmemesint(436)=1792,5040,5376,1568
readmemesint(440)=8094,8400,6901,4680
readmemesint(444)=6496,5520,1584,0

/*dim originesenc,varsize(origines)
repeat varsize(origines)
readmemesint(cnt)=peek(origines,cnt)*peek(enckey,cnt\8)
loop*/

sdim originesmessages,length(readmemesint)
repeat length(readmemesint)
poke originesmessages,cnt,readmemesint(cnt)/peek(enckey,cnt\8)
loop

mes originesmessages

gsel 4,-1
gsel 5,-1
gsel 0,0
setparent settingwindowhwnd,hwnd
setparent settingwindowhwnd2,hwnd
dim dispysize,2
dim dispysize2,4
dim displaydispc,4
dim displaydispc2,4
dim displaydispc3,4
dim crtmodectrls,4
dispysize(0)=20
dispysize(1)=25
dispysize2(0)=40
dispysize2(1)=80
dispysize2(2)=40
dispysize2(3)=80
displaydispc(0)=1
displaydispc(1)=0
displaydispc(2)=1
displaydispc(3)=0
displaydispc2(0)=0
displaydispc2(1)=0
displaydispc2(2)=1
displaydispc2(3)=1
displaydispc3(0)=0
displaydispc3(1)=1
displaydispc3(2)=1
displaydispc3(3)=0
crtmodectrls(0)=0
crtmodectrls(1)=1
crtmodectrls(2)=0
crtmodectrls(3)=1
bload "N80BASIC.ROM",rom(0)
notesel pluginlist
dirlist pluginlist,"plugins/*.ax",1
#ifdef formadgeinitfunc
plaginmax=notemax
#endif
dim plaginconf,128,plaginmax+50
repeat plaginmax+50:cntforcnfsetting=cnt:repeat 5:plaginconf(cnt+1,cntforcnfsetting)=-1:loop:loop
ldim plaginptr,plaginmax+50
ldim sysfunclbl,8192
sysfunclbl(0)=*z80interruptioncall
sysfunclbl(1)=*z80nminterruptioncall
sysfunclbl(2)=*z80memoryget
sysfunclbl(3)=*z80memoryput
sysfunclbl(4)=*controllercall
sysfunclbl(5)=*pluginload
sysfunclbl(6)=*controllercall2
sysfunclbl(7)=*sysfunc_arduino_init
sysfunclbl(8)=*sysfunc_arduino_bye
sysfunclbl(9)=*sysfunc_arduino_query
sysfunclbl(10)=*sysfunc_delay
sysfunclbl(11)=*sysfunc_pinmode
sysfunclbl(12)=*sysfunc_digitalWrite
sysfunclbl(13)=*sysfunc_analogWrite
sysfunclbl(14)=*sysfunc_digitalRead
sysfunclbl(15)=*sysfunc_analogRead
sysfunclbl(16)=*sysfunc_analogReport
sysfunclbl(17)=*sysfunc_digitalReport
sysfunclbl(18)=*sysfunc_analogInterval
sysfunclbl(19)=*sysfunc_arduino_exec
sysfunclbl(20)=*sysfunc_arduino_error
sysfunclbl(21)=*sysfunc_arduino_stat
sysfunclbl(22)=*sysfunc_arduino_ready
sysfunclbl(23)=*sysfunc_arduino_rx
sysfunclbl(24)=*z80ioget
sysfunclbl(25)=*z80ioput
sysfunclbl(26)=*sysfunc_arduino_firm_ver
sysfunclbl(27)=*sysfunc_hspext
sysfunclbl(28)=*sysfunc_z80stackpeek
sysfunclbl(29)=*sysfunc_z80stackpoke
sysfunclbl(30)=*sysfunc_subz80acs
sysfunclbl(31)=*sysfunc_subz80acs2
sysfunctyper=varptr(sysfunclbl)
sdim plaginconfptr,256
#ifdef formadgeinitfunc
interruptformt=1:functyper=0|(0xF<<4):repeat plaginmax:notesel pluginlist:noteget pluginliste,cnt:lpoke plaginptr(cnt),0,_faddproc("plugins/"+pluginliste):if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,varptr(exrom(0)):lpoke plaginconfptr,4*3,varptr(rom):lpoke plaginconfptr,4*4,varptr(fontrom):lpoke plaginconfptr,4*5,varptr(cassettestateptr):lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):lpoke plaginconfptr,4*7,sysfunctyper:pluginid=cnt:gosub plaginptr(cnt)}:loop:interruptformt=0
#endif
dim vramattribute,40,3,25
dim vramattributes,80,25
dim vramattributem,80,25,4
dim vramattributent,25
bload "FONT.ROM",fontrom
bankmax=4
dim bankstat,bankmax
dim bankwriteable,256,bankmax
dim bank,bankmax
graphicdraw=1
cursx=-1
cursy=-1
ldim bpsoundctrlptr,2
bpsoundctrlptr(0)=*bpsoundctlr_b,*bpsoundctlr_a
ldim memoryioportlbl,2,50
ldim memoryioportlblbase,5
memoryioportlblbase(0)=*memacc_memwr,*memacc_memrd,*memacc_iowr,*memacc_iord,*memacc_none
memoryioportlbl(0,0)=*memory_wr_ram
memoryioportlbl(1,0)=*memory_wr_rom
memoryioportlbl(0,1)=*memory_rd_ram
memoryioportlbl(1,1)=*memory_rd_rom
//vramaddr=0xF300
//grpmode=1
//vramaddr=0x6780
//crtmodectrl=1
repeat 3:bankstat(cnt)=0xFF:loop
dim cntxp,2
dim cputimeforz80,2
cputimeforz80(0)=5750
cputimeforz80(1)=7000
//sdim vrambuffer,120*25
/*poke memory,0xF300,65
poke memory,0xF301,66
poke memory,0xF300+80,00
poke memory,0xF300+81,8|128|64|32//|16
poke memory,0xF300+82,00
//poke memory,0xF300+83,128*/
onexit goto *appexitforemuendproc
ddim sgatt,2400
gsel 4,0
oncmd gosub *keydown,$100
oncmd gosub *keyup,$101
gsel 5,0
oncmd gosub *keydown,$100
oncmd gosub *keyup,$101
gsel 0,0
		BeepIsDone:if stat=1{BeepPlay 2400, 0x7FFFFFFF}//t*l-100
		BeepPause
//oncmd gosub *interruptlbl,$113
;settimer hwnd,1,333,0
//settimer hwnd,2,13,0
//settimer hwnd,3,10,0
//settimer hwnd,4,16,0
blinktimest(0)=16,32,48,64
//settimer hwnd,2,25,0
gettine2=gettime(7)
gettmex=gettine2
gettmex2=gettime(6)
if usejit!0{
repeat
z80jitrun address
loop
end
}else{
vbi=1
repeat//cnt*((((blinktimest(blinkingtime)/3)*3)-1)+16)*/:cntmaincs=0
//gettine2=gettime(7)
//gettine3=gettime(7)-(gettine2):gettine3+=1000*(gettine3<0)
cntmain=0
oprestruct=0
//repeat 1000*1000*4:cntmain++//=cnt
//abtime=gettime(6)
beepenabletimex=gettime(7)
repeat
if clocka>=4000000{break}
//if (cnt\2)=0{vbi=1}else{vbi=0}
//gettme=gettime(7)-gettmex:gettme+=(1000*(gettme<0))//if gettme<0{gettme+=1000}
interruptformt=1
vbismacs=1
emulatorexeci=0
vbi=1
//abtime=gettime(7)
cnta=cnt
repeat 66666*5:cntmain++//=cnt
//gosub *bpsoundctlr
vbi=((cntmain\2)=0)
clockaold=clocka:clocka+=z80run_c(address,0):clocktmp=clocka-clockaold
//if (cntmain\32768)=0 and cntmain!0{gosub *bpsoundctlr}
continue cnt+clocktmp//+1
loop
//dialog gettime(7)-abtime
//stop
vbi=0
//repeat 8192:cntmain++//=cnt
//cntmaincs=cnt\((blinktimest(blinkingtime)))
//if cnt\18000=0{await}
//z80run address,0:statx=stat
//gosub *bpsoundctlr
//continue cnt+z80run_c(address,0)//+1
//if (gettine\2)=0{
//if (gettme\16)>12{vbirde=1}else{vbirde=0}
//if (gettme\16)=15{vbi=0}
//if (gettme\16)>13 or (gettme\16)<2{
//if (cntmain\30666)>30600{vbi=0}
//if (cnt\30666)<(30000){
//if (gettme\16)=0{
//loop
/*if (cntmain\32)>24{
vbi=1
}else{
vbi=0
}*/
//vbi=1
//}
emulatorexeci=1
vbismacs=0
//interruptformt=0
//gettine=gettime(7)-gettine2:gettine+=(1000*(gettine<0))
//if (gettine\16)=0{vbi=(vbi=0)}
//if (gettine\17)=8{vbi=(vbi=0)}
/*if (gettine\2){
if cntmain\32>24{
vbi=1
}else{
vbi=0
}

}*/
/*if (gettine\125)=0{
/*if vbi=1{
gosub *drawbackground
gosub *drawforeground
interruptformt=1:functyper=2|(0<<4):repeat plaginmax:gosub *bpsoundctlr:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop:interruptformt=0
await
vbis=0
}*/
//gosub *bpsoundctlr
//}
/*if (gettine\150)=0{
if vbi=1{
gosub *drawbackground
gosub *drawforeground
vbis=0
interruptformt=1:functyper=2|(0<<4):repeat plaginmax:gosub *bpsoundctlr:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop:interruptformt=0
}else{await}
}*/

//if (gettme\16)=0{
//if (cnt\30666)=30000{
//vbi=1
//if cnt\((133330))>133300 and cntmain!0{
//if vbirde=1{
if vbi=0{
gosub *drawbackground
clocka+=22666
gosub *drawforeground
vbis=0//:gosub *bpsoundctlr
interruptformt=1:functyper=2|(0<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop:interruptformt=0
vbirde=0
}//else{await}
/*gosub *drawbackground
gosub *drawforeground*/
//gosub *bpsoundctlr
await
//interruptformt=1:functyper=2|(0<<4):repeat plaginmax:gosub *bpsoundctlr:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop:interruptformt=0
//await
vbis=0
//vbirde=0
//}//else{if (gettme\16)<4{vbi=0}}
interruptformt=1:functyper=0|(0<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop:interruptformt=0
//if (cnt\3)=2 and ((((interruptlevel>>3)&1)=1) or (interruptlevel&0x7)>2){if usejit=0{z80interrupt address,0,2*3}else{z80jitinterrupt address,2*3,0}}else{if (cnt\5)=4 and ((((interruptlevel>>3)&1)=1) or (interruptlevel&0x7)>4){if usejit=0{z80interrupt address,0,2*5}else{z80jitinterrupt address,2*5,0}}}
vbi=0
repeat 8192:cntmain++//=cnt
clockaold=clocka:clocka+=z80run_c(address,0):clocktmp=clocka-clockaold
continue cnt+clocktmp//+1
loop
;gosub *bpsoundctlr
loop
clockab=clocka:beepenabletime=int(0.0006*clocka):clocka=0
;dialog clockab
//abtime=gettime(6)-abtime:if abtime<0{abtime+=60}
//dialog str(abtime)
if (interruptphb&1)!0 and (((((interruptlevel>>3)&1)=1) or (interruptlevel&0x7)>1)){if usejit=0{z80interrupt address,0,2*2}else{z80jitinterrupt address,2*2,0}}
await
interruptformt=0
//gosub *drawforeground
//if vbi=1{
vbi=1
//gosub *drawbackground
//gosub *drawforeground
//interruptformt=1:functyper=2|(0<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop:interruptformt=0
//}
emulatorexeci=1
//dialog gettme
//await
loop
end
}

*drawforeground
interruptformtbaks=interruptformt:interruptformt=1
//redraw 1
gsel 0,0
redraw 0
pos 0,0
gzoom ginfo(26),ginfo(27),3,0,0,640,400,(grpbfsetting!0)
;if scanlinetype=1 or grpbfsetting>=43{color 0,0,0:repeat ginfo(27)/2:line -1,cnt*2,ginfo(26),cnt*2:loop}
if scanlinetype=1 or grpbfsetting>=43{color 0,0,0:repeat int(1.0*(ginfo(27)/(1.0*ginfo(27)/480))):line -1,int((1.0*ginfo(27)/480)*cnt),ginfo(26),int((1.0*ginfo(27)/480)*cnt):loop}
redraw 1
//if grpbfsetting=2{ipmb_smoothinggauss 0,0,ginfo(26),ginfo(27),3,4.0}
//gzoom ginfo(26),ginfo(27),1+displaydispc(pc8001widthflag|(colorgraphicmode<<1)),0,0,8*dispysize2(pc8001widthflag|(colorgraphicmode<<1)),8*dispysize(grpheight25),grpbfsetting=1
interruptformt=interruptformtbaks
return
*oaemah
dim oaeaddt,3:oaeaddt(0)=_z80_addr,_z80_data,_z80_accesstype:memfile oaeaddt
goto oaearchptr
*memoryaccesshnd
interruptformtmacbak=interruptformt:interruptformt=1
//if z80jitfreezeblockerget()\16=0 or cntmain\16=0{
/*if cntmain\16=0{
vbi=1
}else{
vbi=0
}*/
/*switch _z80_accesstype
case 0*/
gosub memoryioportlblbase(_z80_accesstype)
statue=stat:interruptformt=interruptformtmacbak
return statue
*memacc_memwr
//if _z80_addr<0x8000{
goto memoryioportlbl((_z80_addr<0x8000),0)
*memory_wr_rom
if rommode=0 and bankwriteable(bankid,2)=0{
return
}
if bankid=0{
poke memory,_z80_addr,_z80_data
}else{
if bankwriteable(bankid,2)=1{
poke bnkmemory(bankid-1),_z80_addr,_z80_data
}
}
return
//}
*memory_wr_ram
clocka+=1
poke memory,_z80_addr,_z80_data
return
/*swbreak
case 1*/
*memacc_memrd
goto memoryioportlbl((_z80_addr<0x8000),1)
/*if interruptformt=0{
if coutepx=32{
if cntmain\2=0{
vbi=1
}else{
vbi=0
}
coutepx=0
}else{coutepx+=1}
}*/
//if _z80_addr<0x8000 {
*memory_rd_rom
if rommode=0{
if _z80_addr<0x6000 {
return peek(rom(rombank),_z80_addr&0x7FFF)
}
if _z80_addr<0x8000 {
return peek(exrom(romtype),_z80_addr&0x1FFF)
}
}
if bankid=0{
return peek(memory,_z80_addr)
}else{
return peek(bnkmemory(bankid-1),_z80_addr)
}
//}
*memory_rd_ram
clocka+=1
return peek(memory,_z80_addr)
/*swbreak
case 2*/
*memacc_iowr
	logmes "I/O Written:"+str(strf("%02X",_z80_addr&0xFF))
	functyper=2|(1<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*4,_z80_data:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop
	switch _z80_addr&0xFF
	case 0x10
	case 0x11
	case 0x12
	case 0x13
	case 0x14
	case 0x15
	case 0x16
	case 0x17
	case 0x18
	case 0x19
	case 0x1A
	case 0x1B
	case 0x1C
	case 0x1D
	case 0x1E
	case 0x1F
		pch=_z80_data
	swbreak
	case 0x20
	case 0x22
	case 0x24
	case 0x26
	case 0x28
	case 0x2A
	case 0x2C
	case 0x2E
		/*if peek(upd8251config,3)&1{*/functyper=4|(1<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*4,_z80_data:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop//}
	swbreak
	case 0x21
	case 0x23
	case 0x25
	case 0x27
	case 0x29
	case 0x2B
	case 0x2D
	case 0x2F
		if upd8251configate=1{poke upd8251config,3,(_z80_data&0xFF)/*=(upd8251config&0x00FFFFFF)|((_z80_data&0xFF)<<24)*/:if peek(upd8251config,3)&64{upd8251config=0}:if peek(upd8251config,3)&16{overrunerror=0:rxdatareadey=0}}else{poke upd8251config,0,(_z80_data&0xFF)/*upd8251config=(upd8251config&0xFFFFFF00)|((_z80_data&0xFF)<<0)*/}
		upd8251configate++:if upd8251configate>=2{upd8251configate=0}
	swbreak
	case 0x30
	case 0x32
	case 0x34
	case 0x36
	case 0x38
	case 0x3A
	case 0x3C
	case 0x3E
	//dialog _z80_addr&0xF
		cmtbinsnd=(_z80_data>>4)&0x3
		cassettemtstate=(_z80_data>>3)&0x1
		cmtdatawr=(_z80_data>>2)&0x1
		crtmodectrl=(_z80_data>>1)&0x1
		pc8001widthflag=(_z80_data>>0)&0x1
	swbreak
	case 0x31
	case 0x33
	case 0x35
	case 0x37
	case 0x39
	case 0x3B
	case 0x3D
	case 0x3F
		crtc3=_z80_addr
		bgcolor=(_z80_data>>5)&0x7
		colorgraphicmode=(_z80_data>>4)&0x1
		graphicdraw=(_z80_data>>3)&0x1
		grpmode=(_z80_data>>2)&0x1
		rommode=(_z80_data>>1)&0x1
		romtype=(_z80_data>>0)&0x1
	swbreak
	/*case 0x31
		romtype=(_z80_data>>0)&0x1
		rommode=(_z80_data>>1)&0x1
		grpmode=(_z80_data>>2)&0x1
		//crtmodectrl=(_z80_data>>2)&0x1
		graphicdraw=(_z80_data>>3)&0x1
		colorgraphicmode=(_z80_data>>4)&0x1
		bgcolor=(_z80_data>>5)&0x7
	swbreak
	case 0x32
		crtc2=_z80_data
		rombank=_z80_data&0x3
		outputmode=(_z80_data>>2)&0x3
		vrammode=(_z80_data>>4)&0x01
		colourmode=(_z80_data>>5)&0x01
		vramaccessmode=(_z80_data>>6)&0x01
		soundintmaskmode=(_z80_data>>7)&0x01
	swbreak*/
	case 0x40
	case 0x41
	case 0x42
	case 0x43
	case 0x44
	case 0x45
	case 0x46
	case 0x47
	case 0x48
	case 0x49
	case 0x4A
	case 0x4B
	case 0x4C
	case 0x4D
	case 0x4E
	case 0x4F
	//dialog strf("%04X",address)
		uopout=(_z80_data>>6)&0x03
		beepenable=(_z80_data>>5)&0x01
		crtcldsclkenable=(_z80_data>>3)&0x01
		rtcclkenable=(_z80_data>>2)&0x01
		rtcstbenable=(_z80_data>>1)&0x01
		if rtcstbenable=1{gosub *rtcstrobe}else{if rtcclkenable=1{gosub *rtcshift}}
		prtenable=(_z80_data>>0)&0x01:gosub *prtstrobe
		gosub *bpsoundctlr
	swbreak
	case 0x50
	case 0x52
	case 0x54
	case 0x56
	case 0x58
	case 0x5A
	case 0x5C
	case 0x5E
	upd3301prm=_z80_data
	if othercrtcio=0{
		if seq{
			seq-=1
			switch seq+1
				case 1
					colorgraphicmode=(_z80_data>>4)&0x1
					crtcactive=0
				swbreak
				case 3
					grpheight25=(_z80_data & 0x1f) < 9
					blinkingtime=((_z80_data>>6) & 3)
				swbreak
				case 6
					cursx=cursxtmp
					cursy=_z80_data
					seq=0
				swbreak
				case 7
					cursxtmp=_z80_data
				swbreak
			swend
		}
	}else{interruptformt=1:functyper=6|(1<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*4,_z80_data:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop:interruptformt=0}
	swbreak
	case 0x51
	case 0x53
	case 0x55
	case 0x57
	case 0x59
	case 0x5B
	case 0x5D
	case 0x5F
	upd3301cmd=_z80_data
	functyper=8|(1<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*4,_z80_data:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop
		switch _z80_data & 0xF0
		case 0x00
			seq=5
			crtcactive=0
		swbreak
		case 0x60
			if ((_z80_data&0xF))=0{poke upd3301stat,0,peek(upd3301stat,0)&(0xFF-1):upd31speclzsig=1}
		swbreak
		case 0x80
			if ((_z80_data&0xF)&0x01)=0{
				cursx=-1
				cursy=-1
				gettmex2=gettime(6)
			}
			if ((_z80_data&0xF)&0x01)=1{
				seq=7
			}
		swbreak
		swend
	swbreak
	/*case 0x52
		bgcolor=(_z80_data>>3)&0x7
	swbreak*/
	case 0x60
		poke exsbaddr,dma2stackcountes,_z80_data
		dma2stackcountes=dma2stackcountes+1
		if dma2stackcountes=2{dma2stackcountes=0}
	swbreak
	case 0x61
		poke exsbaddrtc,dma2stackcountestc,_z80_data
		dma2stackcountestc=dma2stackcountestc+1
		if dma2stackcountestc=2{dma2stackcountestc=0}
	swbreak
	case 0x62
		poke exsbaddr2,dma2stackcountes2,_z80_data
		dma2stackcountes2=dma2stackcountes2+1
		if dma2stackcountes2=2{dma2stackcountes2=0}
	swbreak
	case 0x63
		poke exsbaddr2tc,dma2stackcountes2tc,_z80_data
		dma2stackcountes2tc=dma2stackcountes2tc+1
		if dma2stackcountes2tc=2{dma2stackcountes2tc=0}
	swbreak
	case 0x64
		poke vramaddr,dma2stackcount,_z80_data
		dma2stackcount=dma2stackcount+1
		if dma2stackcount=2{dma2stackcount=0}
	swbreak
	case 0x65
		poke vramaddrtc,dma2stackcounttc,_z80_data
		dma2stackcounttc=dma2stackcounttc+1
		if dma2stackcounttc=2{dma2stackcounttc=0}
	swbreak
	case 0x66
		poke unusedaddr,dma2stackcountuu,_z80_data
		dma2stackcountuu=dma2stackcountuu+1
		if dma2stackcountuu=2{dma2stackcountuu=0}
	swbreak
	case 0x67
		poke unusedaddrtc,dma2stackcountuutc,_z80_data
		dma2stackcountuutc=dma2stackcountuutc+1
		if dma2stackcountuutc=2{dma2stackcountuutc=0}
	swbreak
	case 0x68
		dmamodestat=_z80_data
		dmaseq=2
	swbreak
	case 0x90
	case 0x91
	case 0x92
	case 0x93
	case 0x94
	case 0x95
	case 0x96
	case 0x97
	case 0x98
	case 0x99
	case 0x9A
	case 0x9B
	case 0x9C
	case 0x9D
	case 0x9E
	case 0x9F
		sgtbl=0.250000f, 0.198582f, 0.157739f, 0.125297f, 0.099527f, 0.079057f, 0.062797f, 0.049882f, 0.039622f, 0.031473f, 0.025000f, 0.019858f, 0.015774f, 0.012530f, 0.009953f, 0.000000f
		if _z80_data&0x80{
			sgregnum = _z80_data >> 4 & 7
			sgosc=sgregnum>>1
			switch sgregnum
			case 0
			case 2
			case 4
				sgtmp=_z80_data&0x0F
			swbreak
			case 1
			case 3
			case 5
			case 7
				sgatt(sgosc)=sgtbl(_z80_data&0x0F)
			swbreak
			case 6
				sgnf = (_z80_data & 3) == 3
				if sgnf{sgfreq(3) = sgfreq(2) << 1}else{sgfreq(3) = 0x20 << (_z80_data & 3)}
				sgwhite = (_z80_data & 4) != 0
			swbreak
			swend
		}else{if sgosc!=3{
							sgfreq(sgosc) = (_z80_data & 0x3f) << 4 | sgtmp
							if (sgfreq(sgosc)=0){sgfreq(sgosc) = 1024}
							if (sgnf && sgosc == 2){sgfreq(3) = sgfreq(2) << 1}
						}
		}
	swbreak
	case 0xE0
	case 0xE1
	case 0xE2
		bankstat(_switch_val-0xE0)=_z80_data^0xFF:repeat 4:bankwriteable(cnt,_switch_val-0xE0)=0:if (_z80_data>>(cnt+4))&0x01 {bankwriteable(cnt,_switch_val-0xE0)=1}:loop:repeat 4:if (_z80_data>>cnt)&0x01 {bank(_switch_val-0xE0)=cnt:break}:loop
	swbreak
	case 0xE3
		bankid=_z80_data
	swbreak
	case 0xE4
		interruptlevel=_z80_data&0xF
	swbreak
	case 0xE6
		interruptphb=_z80_data&0x7
	swbreak
	case 0xFC
	if (fc_i8255view&128)!0{
		switch (fc_ptabcmode>>1)&3
		case 0
			functyper=0|(3<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*4,_z80_data&((((fc_portabcrw&1)=0)*0xFF)):lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop
		swbreak
		case 1
			i8255md1sigbufa=_z80_data&0xFF
			i8255md1sig|=0x80//functyper=0|(3<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*4,_z80_data:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop
			if i8255md1sig&0x08{i8255md1sig^=0x08}
		swbreak
		case 2
		case 3
			i8255md1sigbufa=_z80_data&0xFF
			i8255md1sig|=0x80
			if i8255md1sig&0x08{i8255md1sig^=0x08}
		swbreak
		swend
	}
	swbreak
	case 0xFD
	if (fc_i8255view&128)!0{
		if ((fc_ptabcmode>>3)&1)=0{
			functyper=1|(3<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*4,_z80_data&((((fc_portabcrw&2)=0)*0xFF)):lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop
		}else{
			//functyper=1|(3<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*4,_z80_data:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop
			i8255md1sigbufb=_z80_data&0xFF
			i8255md1sig|=0x02
			if i8255md1sig&0x01{i8255md1sig^=0x01}
		}
	}
	swbreak
	case 0xFE
*writefdc8255io_pc
		i8255md1sig=_z80_data&0xFF
			if ((fc_ptabcmode>>3)&1)=0 and ((fc_ptabcmode>>1)&3)!0{
				functyper=2|(3<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,0:lpoke plaginconfptr,4*4,(_z80_data)&(((fc_portabcrw&8)=0)*0x3):lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop
			}
		switch (fc_ptabcmode>>1)&3
		case 0
			if ((fc_ptabcmode>>3)&1)=0{
				functyper=2|(3<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,0:lpoke plaginconfptr,4*4,(_z80_data)&((((fc_portabcrw&8)=0)*0xF)|(((fc_portabcrw&4)=0)*0xF0)):lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop
			}else{
				functyper=2|(3<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,0:lpoke plaginconfptr,4*4,(_z80_data)&(((fc_portabcrw&8)=0)*0xF):lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop
			}
		swbreak
		case 1
			i8255md1sig=_z80_data&0xFF
			if ((i8255md1sig&8)!0) and (((fc_ptabcmode>>3)&1)!0){
			}
		swbreak
		case 2
		case 3
			i8255md1sig=_z80_data&0xFF
		swbreak
		swend
		/*case 1
			functyper=2|(3<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,0:lpoke plaginconfptr,4*4,(_z80_data):lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop
		swbreak*/
		if (fc_i8255view&128)=0{return}
	swbreak
	case 0xFF
	fc_i8255view=_z80_data&0xFF
	if ((_z80_data&128)!0){
		fc_ptabcmode=(((_z80_data&128)!0)<<0)|(((_z80_data>>5)&3)<<1)|(((_z80_data&4)!0)<<3)
		fc_portabcrw=(((_z80_data&16)!0)<<0)|(((_z80_data&2)!0)<<1)|(((_z80_data&8)!0)<<2)|(((_z80_data&1)!0)<<3)
		/*if ((fc_ptabcmode>>3)&1)=1{i8255md1sig=(fc_portabcrw<<2)&96}else{
		if ((fc_ptabcmode>>1)&3)=1{i8255md1sig=(fc_portabcrw<<1)&8}}*/
	}else{
		fc_bsrmode=((_z80_data>>1)&7)|(((_z80_data&1)!0)<<3)
		_z80_dataold=_z80_data:fc_bsrmodex&=0xFF-(1<<((_z80_data>>1)&7)):fc_bsrmodex|=(_z80_data&0x1)<<((_z80_data>>1)&7)
		_z80_data=fc_bsrmodex:gosub *writefdc8255io_pc
		_z80_data=_z80_dataold
	}
	swbreak
	swend
	functyper=0|(1<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*4,_z80_data:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop
return
/*swbreak
case 3*/
*memacc_iord
	logmes "I/O Read:"+str(strf("%02X",_z80_addr&0xFF))
	lpoke plaginconfptr,4*5,0
	functyper=3|(1<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt):if lpeek(plaginconf,4*5)=1{break}}:loop
	if lpeek(plaginconfptr,4*5)=1{lpoke plaginconfptr,4*5,0:return lpeek(plaginconfptr,4*4)}
	switch _z80_addr&0xFF
	case 0x00
	case 0x01
	case 0x02
	case 0x03
	case 0x04
	case 0x05
	case 0x06
	case 0x07
	case 0x08
	case 0x09
	case 0x0A
	case 0x0B
	case 0x0C
	case 0x0D
	case 0x0E
	case 0x0F
		return 0xFF^keyio(_z80_addr&0xF)
	swbreak
	case 0x20
	case 0x22
	case 0x24
	case 0x26
	case 0x28
	case 0x2A
	case 0x2C
	case 0x2E
		if peek(upd8251config,3)&4{
		lpoke plaginconfptr,4*5,0
		functyper=5|(1<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt):if lpeek(plaginconf,4*5)=1{break}}:loop
		if lpeek(plaginconfptr,4*5)=1{lpoke plaginconfptr,4*5,0:overrunerror=0:/*if rxdatareadey=1{overrunerror=1}else{*/poke upd8251config,2,lpeek(plaginconfptr,4*4):if peek(upd8251config,3)&32{pvpvbtbt=0}else{pvpvbtbt=1}:repeat 8:if (peek(upd8251config,2)>>cnt)&1{pvpvbtbt++}:loop:if peek(upd8251config,3)&16{pvpvbtbt=0}:rxdatareadey=1/*}*/:poke upd8251config,1,(((pvpvbtbt\2)!0)<<3)|((overrunerror!0)<<4)}
		}
		return peek(upd8251config,2)
	swbreak
	case 0x21
	case 0x23
	case 0x25
	case 0x27
	case 0x29
	case 0x2B
	case 0x2D
	case 0x2F
		/*rxdatareadeybak=rxdatareadey:rxdatareadey=0*/:return (((upd8251config>>8)&0xFF)|((rxdatareadey!0)<<1))|((peek(upd8251config,3)&1)<<0)//(_switch_val&0x01)*0xE1
	swbreak
	case 0x30
	case 0x32
	case 0x34
	case 0x36
	case 0x38
	case 0x3A
	case 0x3C
	case 0x3E
		return crtc2
	swbreak
	case 0x31
	case 0x33
	case 0x35
	case 0x37
	case 0x39
	case 0x3B
	case 0x3D
	case 0x3F
		return ((bgcolor&0x7)<<5)|((colorgraphicmode&0x01)<<4)|((graphicdraw&0x01)<<3)|((grpmode&0x01)<<2)|((rommode&0x01)<<1)|((romtype&0x01)<<0)
	swbreak
	case 0x40
	case 0x41
	case 0x42
	case 0x43
	case 0x44
	case 0x45
	case 0x46
	case 0x47
	case 0x48
	case 0x49
	case 0x4A
	case 0x4B
	case 0x4C
	case 0x4D
	case 0x4E
	case 0x4F
	logmes "0x40 i/o access:"+strf("%04X",address)
		return ((uipin&3)<<6)|(vbi<<5)|((rtcdata&1)<<4)|(((fddconnected&1)!1)<<3)|((cmtdatard&1)<<2)|((prtready&1)<<0)//0x0a//0x5//|0x0a
	swbreak
	case 0x50
	case 0x52
	case 0x54
	case 0x56
	case 0x58
	case 0x5A
	case 0x5C
	case 0x5E
		if othercrtcio=1{
			lpoke plaginconfptr,4*5,0
			functyper=7|(1<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt):if lpeek(plaginconf,4*5)=1{break}}:loop
			if lpeek(plaginconfptr,4*5)=1{lpoke plaginconfptr,4*5,0:return lpeek(plaginconfptr,4*4)}else{othercrtcio=0}
		}
		if upd31speclzsig=0{return upd3301prm}else{
			switch peek(upd31speclzsig,0)
			case 1
				ret=peek(litepeninp,peek(upd31speclzsig,1))
			swbreak
			swend
		poke upd31speclzsig,1,peek(upd31speclzsig,1)+1
		if peek(upd31speclzsig,1)>=2{upd31speclzsig=0:litepeninp=0}
		return ret
		}
	swbreak
	case 0x51
	case 0x53
	case 0x55
	case 0x57
	case 0x59
	case 0x5B
	case 0x5D
	case 0x5F
		if othercrtcio=1{
			lpoke plaginconfptr,4*5,0
			functyper=9|(1<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt):if lpeek(plaginconf,4*5)=1{break}}:loop
			if lpeek(plaginconfptr,4*5)=1{lpoke plaginconfptr,4*5,0:upd3301stat=lpeek(plaginconfptr,4*4)}else{othercrtcio=0}
		}
		//upd3301statbak=upd3301stat:upd3301stat=0xFF-0x1F
		if upd3301stat&8{return upd3301stat&(0xFF-0x10)}else{return upd3301stat}
	swbreak
	case 0x60
		ret6466x=peek(exsbaddr,dma2stackcountes)
		dma2stackcountes=dma2stackcountes+1
		if dma2stackcountes=2{dma2stackcountes=0}
		return ret6466x
	swbreak
	case 0x61
		ret6466x=peek(exsbaddrtc,dma2stackcountestc)
		dma2stackcountestc=dma2stackcountestc+1
		if dma2stackcountestc=2{dma2stackcountestc=0}
		return ret6466x
	swbreak
	case 0x62
		ret6466x=peek(exsbaddr2,dma2stackcountes2)
		dma2stackcountes2=dma2stackcountes2+1
		if dma2stackcountes2=2{dma2stackcountes2=0}
		return ret6466x
	swbreak
	case 0x63
		ret6466x=peek(exsbaddr2tc,dma2stackcountes2tc)
		dma2stackcountes2tc=dma2stackcountes2tc+1
		if dma2stackcountes2tc=2{dma2stackcountes2tc=0}
		return ret6466x
	swbreak
	case 0x64
		ret6466x=peek(vramaddr,dma2stackcount)
		dma2stackcount=dma2stackcount+1
		if dma2stackcount=2{dma2stackcount=0}
		return ret6466x
	swbreak
	case 0x65
		ret6466x=peek(vramaddrtc,dma2stackcounttc)
		dma2stackcounttc=dma2stackcounttc+1
		if dma2stackcounttc=2{dma2stackcounttc=0}
		return ret6466x
	swbreak
	case 0x66
		ret6466x=peek(unusedaddr,dma2stackcountuu)
		dma2stackcountuu=dma2stackcountuu+1
		if dma2stackcountuu=2{dma2stackcountuu=0}
		return ret6466x
	swbreak
	case 0x67
		ret6466x=peek(unusedaddrtc,dma2stackcountuutc)
		dma2stackcountuutc=dma2stackcountuutc+1
		if dma2stackcountuutc=2{dma2stackcountuutc=0}
		return ret6466x
	swbreak
	case 0x68
		return dmamodestat|((1<<4)*((cntmain\19)>9))
	swbreak
	case 0xE0
	case 0xE1
	case 0xE2
		return bankstat(_switch_val-0xE0)
	swbreak
	case 0xE3
		return bankid
	swbreak
	case 0xE4
		return interruptlevel
	swbreak
	case 0xFC
	if (fc_i8255view&128)!0{
		switch (fc_ptabcmode>>1)&3
		case 0
			lpoke plaginconfptr,4*4,0
			lpoke plaginconfptr,4*5,0
			functyper=3|(3<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt):if lpeek(plaginconf,4*5)=1{break}}:loop
			if lpeek(plaginconfptr,4*5)=1{lpoke plaginconfptr,4*5,0:return lpeek(plaginconfptr,4*4)&((((fc_portabcrw&1)!0)*0xFF))}
			return lpeek(plaginconfptr,4*4)&((((fc_portabcrw&1)!0)*0xFF))
		swbreak
		case 1
			i8255md1sigbufaold=i8255md1sigbufa:i8255md1sigbufa=0
			i8255md1sig|=0x08
			if i8255md1sig&0x80{i8255md1sig^=0x80}
			return i8255md1sigbufaold
		case 2
		case 3
			i8255md1sigbufaold=i8255md1sigbufa:i8255md1sigbufa=0
			i8255md1sig|=0x08
			if i8255md1sig&0x80{i8255md1sig^=0x80}
			return i8255md1sigbufaold
		swbreak
		swend
	}
	swbreak
	case 0xFD
	if (fc_i8255view&128)!0{
		if (fc_ptabcmode>>3)&1{
			lpoke plaginconfptr,4*4,0
			lpoke plaginconfptr,4*5,0
			functyper=4|(3<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt):if lpeek(plaginconf,4*5)=1{break}}:loop
			if lpeek(plaginconfptr,4*5)=1{lpoke plaginconfptr,4*5,0:return lpeek(plaginconfptr,4*4)&((((fc_portabcrw&2)!0)*0xFF))}
			return lpeek(plaginconfptr,4*4)&((((fc_portabcrw&2)!0)*0xFF))
		}else{
			i8255md1sigbufbold=i8255md1sigbufb:i8255md1sigbufb=0
			i8255md1sig|=0x01
			if i8255md1sig&0x02{i8255md1sig^=0x02}
			return i8255md1sigbufbold
		}
	}
	swbreak
	case 0xFE
		if fc_i8255view&128{
			switch (fc_ptabcmode>>1)&3
			case 0
				lpoke plaginconfptr,4*4,0
				lpoke plaginconfptr,4*5,0
				functyper=5|(3<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,(fc_bsrmode&7):lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt):if lpeek(plaginconf,4*5)=1{break}}:loop
				if lpeek(plaginconfptr,4*5)=1{lpoke plaginconfptr,4*5,0:return lpeek(plaginconfptr,4*4)&((((fc_portabcrw&8)!0)*0xF)|(((fc_portabcrw&4)!0)*0xF0))|(i8255md1sig&0xF)}
				return lpeek(plaginconfptr,4*4)&((((fc_portabcrw&8)!0)*0xF)|(((fc_portabcrw&4)!0)*0xF0))|(i8255md1sig&0xF)
			swbreak
			case 1
				return (i8255md1sig&0xFF)
				//return (i8255md1sig&0xF)|(((i8255md1sig>>6)&3)<<4)||(((i8255md1sig>>4)&3)<<6)
			swbreak
			case 2
			case 3
				return (i8255md1sig&0xFF)
				//return (i8255md1sig&0x7)|(i8255md1sig&0xF8)
			swbreak
			swend
		}else{
				lpoke plaginconfptr,4*4,0
				lpoke plaginconfptr,4*5,0
				functyper=5|(3<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,(fc_bsrmode&7):lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt):if lpeek(plaginconf,4*5)=1{break}}:loop
				if lpeek(plaginconfptr,4*5)=1{lpoke plaginconfptr,4*5,0:return lpeek(plaginconfptr,4*4)}
				return lpeek(plaginconfptr,4*4)
		}
	swbreak
	case 0xFF
		return (fc_i8255view)&0xFF
	swbreak
	swend
	lpoke plaginconfptr,4*5,0
	functyper=1|(1<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,_z80_addr:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt):if lpeek(plaginconf,4*5)=1{break}}:loop
	if lpeek(plaginconfptr,4*5)=1{lpoke plaginconfptr,4*5,0:return lpeek(plaginconfptr,4*4)}else{return 0xFF}
return
/*swbreak
swend*/
*memacc_none
return

*rtcstrobe
dim timezforch1,9
timezforch1(0)=rtctimeforminus(0)\60,rtctimeforminus(1)\60,rtctimeforminus(2)\24,rtctimeforminus(3)\32,(rtctimeforminus(4)-1)\12,71,0,0,0
timerforch123=time(0)-mktime(varptr(timexforch1))+mktime(varptr(timezforch1))
dupptr timey,localtime(varptr(timerforch123)),36,4
dim rtctimeforminusck,5:rtctimeforminusck(0)=6,5,4,3,1
dim rtctimeforminusck3,5:rtctimeforminusck3(0)=59,59,23,31,12
dim rtctimeforminusck2,5:rtctimeforminusck2(0)=timey(0):rtctimeforminusck2(1)=timey(1):rtctimeforminusck2(2)=timey(2):rtctimeforminusck2(3)=timey(3):rtctimeforminusck2(4)=timey(4)+1//repeat 5:rtctimeforminusck2(cnt)=(gettime(rtctimeforminusck(cnt))+rtctimeforminus(cnt))\(rtctimeforminusck3(cnt)+1):loop
switch pch & 0xF
case 1
rtcpos=0
dim rtctimetmp,5
rtctime(4)=rtctimeforminusck2(4)<<4
rtctime(3)=((rtctimeforminusck2(3)/10)<<4)+rtctimeforminusck2(3)\10
rtctime(2)=((rtctimeforminusck2(2)/10)<<4)+rtctimeforminusck2(2)\10
rtctime(1)=((rtctimeforminusck2(1)/10)<<4)+rtctimeforminusck2(1)\10
rtctime(0)=((rtctimeforminusck2(0)/10)<<4)+rtctimeforminusck2(0)\10
rtcdata=rtctime(0)&0x01
swbreak
case 2
repeat 5:rtctime(cnt)=rtctimetmp(cnt):loop
repeat 5
if cnt!4{rtctimeforminus(cnt)=(((rtctime(cnt)>>4)*10)+(rtctime(cnt)&15))}else{rtctimeforminus(cnt)=(rtctime(cnt)>>4)}
loop
swbreak
swend
return
*rtcshift
if rtcpos<40{
rtctimetmp(rtcpos>>3)|= (pch >> 3 & 1) << (rtcpos & 7)
rtcpos+=1
rtcdata=rtctime(rtcpos >> 3) >> (rtcpos & 7) & 1
}
return

*prtstrobe
	if prtenable & prtenable0!=0 & pch!='\r'{}
	prtenable0=prtenable
return

*drawbackground
interruptformtbakfordw=interruptformt
interruptformt=1:functyper=1|(0<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop:interruptformt=1
gettine=(gettime(7)-gettine2):gettine+=(1000*(gettine<0))//:gettine/=2
//vbi=1
emulatorexeci=0
colourchanged=0
palletedcolorchkold=256
cntmaincs+=((blinktimest(blinkingtime))-1)
vbis=1
if oprestruct=0{
if (interruptphb&2)!0 and (interruptix\2)=0 and (((((interruptlevel>>3)&1)=1) or (interruptlevel&0x7)>0)){if usejit=0{z80interrupt address,0,2*1}else{z80jitinterrupt address,2*1,0}}
}
if useoldrender=1{
if graphicdraw=1{
gsel 1+displaydispc(pc8001widthflag|(colorgraphicmode<<1)),0
redraw 0
//repeat 120*25:poke vrambuffer,cnt,z80readmem(vramaddr+cnt):loop
//vbi=1
switch videomode
case 0
if crtmodectrl=0{palcolor bgcolor:boxf}else{palcolor 8:boxf}
/*palcolor 7+(0x10*(((vramattributent(cnt/80)>>3)&0x1)=0)):*///if cursx!-1 and cursy!-1{if (gettine\blinktimest(blinkingtime))<(blinktimest(blinkingtime)/2){boxf ((cursx/((pc8001widthflag=0)+1))*8),(cursy*8),((cursx/((pc8001widthflag=0)+1))*8)+7,(cursy*8)+7}}
repeat 20*25:vramattribute((cnt\20),0,(cnt/20))=0:vramattribute((cnt\20),1,(cnt/20))=0:vramattribute((cnt\20),2,(cnt/20))=0:loop:cc128ccbak2=0:cc128ccbak=0:attributeolder=-1:repeat 40:vramattributent(cnt)=0:loop:cc128cc=0:cc128ccc=0:repeat 20*25:if (cnt\20)=0{cc128cc=0}:z80memaccess (vramaddr+80+((cnt\20)*2)+((cnt/20)*120)+0)&0xFFFF,0,1:vramattribute(((cnt\20)*2),2,(cnt/20))=stat/*z80readmem(vramaddr+80+((cnt\20)*2)+((cnt/20)*120)+0)*/:if vramattribute(((cnt\20)*2),2,(cnt/20))&128{cc128cc+=1:if (vramattribute(((cnt\20)*2),2,(cnt/20))&128)!0 /*and attributeolder!(cnt/20)*/{vramattributent(cnt/20)=vramattribute(((cnt\20)*2),2,(cnt/20))&127:attributeolder=(cnt/20)}}:if (vramattribute(((cnt\20)*2),2,(cnt/20))&128)=0{vramattribute((cnt\20)-cc128cc,0,(cnt/20))=vramattribute(((cnt\20)*2),2,(cnt/20))&127}:z80memaccess (vramaddr+80+((cnt\20)*2)+((cnt/20)*120)+1)&0xFFFF,0,1:vramattribute(((cnt\20)*2)+1,2,(cnt/20))=stat/*z80readmem(vramaddr+80+((cnt\20)*2)+((cnt/20)*120)+1)*/:if (vramattribute(((cnt\20)*2),2,(cnt/20))&128)=0{vramattribute((cnt\20)-cc128cc,1,(cnt/20))=vramattribute(((cnt\20)*2)+1,2,(cnt/20))}:loop
executext=0:cntx=0:repeat 80*25:cntap=cnt:repeat 20:if vramattribute((cnt\20),0,(cntap/80))<=(cntap\80) /*and ((vramattribute((cntx\20),1,(cnt/80))&8)!0)=0*/{cntx=cnt}:loop:if vramattribute((cntx\20),0,(cnt/80))<=(cnt\80){vramattributem((cnt\80),(cnt/80),3)=vramattribute((cntx\20),1,(cnt/80))}:/*loop:executext=0:cntx=0:repeat 80*25:*/cntap=cnt:repeat 20:if vramattribute((cnt\20),0,(cntap/80))<=(cntap\80) and ((vramattribute((cnt\20),1,(cntap/80))&8)!0)=0 /*and ((vramattribute((cntx\20),1,(cnt/80))&8)!0)=0*/{cntx=cnt}:loop:if vramattribute((cntx\20),0,(cnt/80))<=(cnt\80) and ((vramattribute((cntx\20),1,(cnt/80))&8)!0)=0{vramattributem((cnt\80),(cnt/80),0)=vramattribute((cntx\20),1,(cnt/80))}:if crtmodectrl=0{cntap=cnt:repeat 20:if vramattribute((cnt\20),0,(cntap/80))<=(cntap\80) and ((vramattribute((cnt\20),1,(cntap/80))&8)!0)=1/* and ((vramattribute((cnt\20),1,(cntap/80))&16)!0)=0*/{cntx=cnt}:loop:if vramattribute((cntx\20),0,(cnt/80))<=(cnt\80) and ((vramattribute((cntx\20),1,(cnt/80))&8)!0)=1 /*and ((vramattribute((cnt\20),1,(cntap/80))&16)!0)=0*/{vramattributem((cnt\80),(cnt/80),1)=vramattribute((cntx\20),1,(cnt/80))}/*:cntap=cnt:repeat 20:if vramattribute((cnt\20),0,(cntap/80))<=(cntap\80) and ((vramattribute((cnt\20),1,(cntap/80))&8)!0)=1 and ((vramattribute((cnt\20),1,(cntap/80))&16)!0)=1{cntx=cnt}:loop:if vramattribute((cntx\20),0,(cnt/80))<=(cnt\80) and ((vramattribute((cntx\20),1,(cnt/80))&8)!0)=1 and ((vramattribute((cntx\20),1,(cnt/80))&16)!0)=1{vramattributem((cnt\80),(cnt/80),2)=vramattribute((cntx\20),1,(cnt/80))}*/}:grpccnt=cnt
z80memaccess (vramaddr+(120*(grpccnt/80))+((grpccnt\80)*((displaydispc2(pc8001widthflag|(colorgraphicmode<<1))=0)+1)))&0xFFFF,0,1:fontid=stat/*z80readmem(vramaddr+(120*(grpccnt/80))+((grpccnt\80)*((displaydispc2(pc8001widthflag|(colorgraphicmode<<1))=0)+1)))*/
attributedata=vramattributem((cnt\80),(cnt/80),0) | (vramattributent(cnt/80)&119)
attributedata2=vramattributem((cnt\80),(cnt/80),3)
if colourchanged=1 or colorgraphicmode=1{
switch crtmodectrl
case 0
if colorgraphicmode=0 and grpmode=1{palcolor 9+(0x10*(((vramattributent(cnt/80)>>3)&0x1)=0)):palletedcolorchkold=256}else{palletedcolorchk=(vramattributem((cnt\80),(cnt/80),/*1+((((attributedata2>>7)and(attributedata2>>3))|((attributedata2>>4)&(vramattributem((cnt\80),(cnt/80),0)>>3)))&0x1)*/1)>>5)+(0x10*(((vramattributent(cnt/80)>>3)&0x1)=0))+(0x20*((grpmode=0))):if palletedcolorchkold!palletedcolorchk{palcolor palletedcolorchk}:palletedcolorchkold=palletedcolorchk}
swbreak
case 1
palcolor 9+(0x10*(((vramattributent(cnt/80)>>3)&0x1)=0)):palletedcolorchkold=256
swbreak
swend
colourchanged=0
}
//if cursx!-1 and cursy!-1{if (gettine\blinktimest(blinkingtime))<(blinktimest(blinkingtime)/2){if cursx=(grpccnt\80) and cursy=(grpccnt/80){boxf ((cursx/((pc8001widthflag=0)+1))*8),(cursy*8),((cursx/((pc8001widthflag=0)+1))*8)+7,(cursy*8)+7}}}
//if grpmode=0{attributedata=vramattributem((cnt\80),(cnt/80),0):palcolor (vramattributem((cnt\80),(cnt/80),1+((attributedata>>7)&0x1))>>5)}
//dialog attributedata
//stop
if attributedata&0x1{}else{
if (displaydispc3(pc8001widthflag|(colorgraphicmode<<1))=0)=0 and grpccnt\2=1{}else{
if (((attributedata2&128)!0) and ((attributedata2&8)=0)) or (((attributedata2&16)!0) and ((attributedata2&8)=8)) {
repeat 8
if (fontid>>cnt) & 0x01{boxf (((grpccnt\80)/(displaydispc3(pc8001widthflag|(colorgraphicmode<<1))+1))*8)+4*(cnt/4),((grpccnt/80)*8)+2*(cnt\4),(((grpccnt\80)/(displaydispc3(pc8001widthflag|(colorgraphicmode<<1))+1))*8)+4*((cnt/4)+1)-1,((grpccnt/80)*8)+2*((cnt\4)+1)-1}
loop
if cursx!-1 and cursy!-1{if (gettine\blinktimest(blinkingtime))<(blinktimest(blinkingtime)/2){if cursx=(grpccnt\80) and cursy=(grpccnt/80){palcolor 0+(0x10*(((vramattributent(cnt/80)>>3)&0x1)=0)):boxf ((cursx/((pc8001widthflag=0)+1))*8),(cursy*8),((cursx/((pc8001widthflag=0)+1))*8)+7,(cursy*8)+7:palletedcolorchkold=256}}}
}else{
if cursx!-1 and cursy!-1{if (gettine\blinktimest(blinkingtime))<(blinktimest(blinkingtime)/2){if cursx=(grpccnt\80) and cursy=(grpccnt/80){boxf ((cursx/((pc8001widthflag=0)+1))*8),(cursy*8),((cursx/((pc8001widthflag=0)+1))*8)+7,(cursy*8)+7}}}
/*fontidx="":lpoke fontidx,0,fontid
dialog fontidx*/
if attributedata&0x4{boxf ((int(double(0.5*((pc8001widthflag!0)+1))*(grpccnt\80)))*8),((grpccnt/80)*8),((int(double(0.5*((pc8001widthflag!0)+1))*(grpccnt\80)))*8)+7,(((grpccnt/80)*8)+7):colourchanged=1:if crtmodectrl=0{palcolor bgcolor}else{palcolor 8}:palletedcolorchkold=256}
if cursx!-1 and cursy!-1{if (gettine\blinktimest(blinkingtime))<(blinktimest(blinkingtime)/2){if cursx=(grpccnt\80) and cursy=(grpccnt/80){colourchanged=1:if crtmodectrl=0{palcolor bgcolor}else{palcolor 8}:palletedcolorchkold=256}}}
if (attributedata&0x1)=0 and (attributedata&0x2)=2 and (gettine\(blinktimest(blinkingtime)*2))>((blinktimest(blinkingtime)*2)/4){boxf ((int(double(0.5*((pc8001widthflag!0)+1))*(grpccnt\80)))*8),((grpccnt/80)*8),((int(double(0.5*((pc8001widthflag!0)+1))*(grpccnt\80)))*8)+7,(((grpccnt/80)*8)+7):colourchanged=1:if crtmodectrl=0{palcolor bgcolor}else{palcolor 8}:palletedcolorchkold=256}
pos ((grpccnt\80)/(displaydispc3(pc8001widthflag|(colorgraphicmode<<1))+1))*8,(grpccnt/80)*8
fontrend fontid
}
if attributedata&16{boxf (((grpccnt\80)/(displaydispc3(pc8001widthflag|(colorgraphicmode<<1))+1))*8),((grpccnt/80)*8),(((grpccnt\80)/(displaydispc3(pc8001widthflag|(colorgraphicmode<<1))+1))*8)+7,((grpccnt/80)*8)+1}
if attributedata&32{boxf (((grpccnt\80)/(displaydispc3(pc8001widthflag|(colorgraphicmode<<1))+1))*8),((grpccnt/80)*8)+6,(((grpccnt\80)/(displaydispc3(pc8001widthflag|(colorgraphicmode<<1))+1))*8)+7,((grpccnt/80)*8)+7}
if attributedata&64{boxf (((grpccnt\80)/(displaydispc3(pc8001widthflag|(colorgraphicmode<<1))+1))*8)+4,((grpccnt/80)*8),(((grpccnt\80)/(displaydispc3(pc8001widthflag|(colorgraphicmode<<1))+1))*8)+5,((grpccnt/80)*8)+7}
}
}
loop
swbreak
swend
/*else{
switch crtmodectrl
case 0
if colorgraphicmode=0 and grpmode=1{palcolor 9+(0x10*(((attributedata>>1)&0x1)=0))}else{palletedcolorchk=(vramattributem((cnt\80),(cnt/80),/*1+((((attributedata2>>7)and(attributedata2>>3))|((attributedata2>>4)&(vramattributem((cnt\80),(cnt/80),0)>>3)))&0x1)*//*1)>>5)+(0x10*(((attributedata>>1)&0x1)=0))+(0x20*((grpmode=0))):palcolor palletedcolorchk}
swbreak
case 1
palcolor 9+(0x10*(((attributedata>>1)&0x1)=0))
swbreak
swend
}*/
//gettme2=gettime(6)-gettmex2:if gettme2<0{gettme2+=1000}
//if crtmodectrl=0{}
gsel 3,0
pos 0,0
gzoom 640,400,1+displaydispc(pc8001widthflag|(colorgraphicmode<<1)),0,0,8*dispysize2(pc8001widthflag|(colorgraphicmode<<1)),8*dispysize(grpheight25),(grpbfsetting!0):if grpbfsetting<=1{}else{if grpbfsetting=2{ipmb_smoothingtype1 0,0,ginfo(26),ginfo(27)}else{if grpbfsetting>=3 and grpbfsetting<=12{ipmb_smoothingtype2 0,0,ginfo(26),ginfo(27),(grpbfsetting-1)}else{if grpbfsetting>=13 and grpbfsetting<=22{ipmb_unsharpmasking 0,0,ginfo(26),ginfo(27),1,double(grpbfsetting-12)}else{if grpbfsetting>=23 and grpbfsetting<=32{ipmb_smoothinggauss 0,0,ginfo(26),ginfo(27),1,double(grpbfsetting-22)}else{if grpbfsetting>=33 and grpbfsetting<=42{ipmb_sharp 0,0,ginfo(26),ginfo(27),double(grpbfsetting-32)}else{if grpbfsetting>=43{ipmb_smoothingtype1 0,0,ginfo(26),ginfo(27)}}}}}}}
redraw 1
//statx+=24000
}else{gsel 3,0:color 0,0,0:boxf:redraw 1}
}else{
hgdraw 0
if graphicdraw=1{
gsel 5,0
//gsel 1+displaydispc(pc8001widthflag|(colorgraphicmode<<1)),0
redraw 0
//repeat 120*25:poke vrambuffer,cnt,z80readmem(vramaddr+cnt):loop
//vbi=1
switch videomode
case 0
if crtmodectrl=0{palcolor_hg bgcolor:hgrect 0,0,0,mwxs,mwys}else{palcolor_hg 8:hgrect 0,0,0,mwxs,mwys}
/*palcolor_hg 7+(0x10*(((vramattributent(cnt/80)>>3)&0x1)=0)):*///if cursx!-1 and cursy!-1{if (gettine\blinktimest(blinkingtime))<(blinktimest(blinkingtime)/2){boxf ((cursx/((pc8001widthflag=0)+1))*8),(cursy*8),((cursx/((pc8001widthflag=0)+1))*8)+7,(cursy*8)+7}}
repeat 20*25:vramattribute((cnt\20),0,(cnt/20))=0:vramattribute((cnt\20),1,(cnt/20))=0:vramattribute((cnt\20),2,(cnt/20))=0:loop:cc128ccbak2=0:cc128ccbak=0:attributeolder=-1:repeat 40:vramattributent(cnt)=0:loop:cc128cc=0:cc128ccc=0:repeat 20*25:if (cnt\20)=0{cc128cc=0}:z80memaccess (vramaddr+80+((cnt\20)*2)+((cnt/20)*120)+0)&0xFFFF,0,1:vramattribute(((cnt\20)*2),2,(cnt/20))=stat/*z80readmem(vramaddr+80+((cnt\20)*2)+((cnt/20)*120)+0)*/:if vramattribute(((cnt\20)*2),2,(cnt/20))&128{cc128cc+=1:if (vramattribute(((cnt\20)*2),2,(cnt/20))&128)!0 /*and attributeolder!(cnt/20)*/{vramattributent(cnt/20)=vramattribute(((cnt\20)*2),2,(cnt/20))&127:attributeolder=(cnt/20)}}:if (vramattribute(((cnt\20)*2),2,(cnt/20))&128)=0{vramattribute((cnt\20)-cc128cc,0,(cnt/20))=vramattribute(((cnt\20)*2),2,(cnt/20))&127}:z80memaccess (vramaddr+80+((cnt\20)*2)+((cnt/20)*120)+1)&0xFFFF,0,1:vramattribute(((cnt\20)*2)+1,2,(cnt/20))=stat/*z80readmem(vramaddr+80+((cnt\20)*2)+((cnt/20)*120)+1)*/:if (vramattribute(((cnt\20)*2),2,(cnt/20))&128)=0{vramattribute((cnt\20)-cc128cc,1,(cnt/20))=vramattribute(((cnt\20)*2)+1,2,(cnt/20))}:loop
executext=0:cntx=0:repeat 80*25:cntap=cnt:repeat 20:if vramattribute((cnt\20),0,(cntap/80))<=(cntap\80) /*and ((vramattribute((cntx\20),1,(cnt/80))&8)!0)=0*/{cntx=cnt}:loop:if vramattribute((cntx\20),0,(cnt/80))<=(cnt\80){vramattributem((cnt\80),(cnt/80),3)=vramattribute((cntx\20),1,(cnt/80))}:/*loop:executext=0:cntx=0:repeat 80*25:*/cntap=cnt:repeat 20:if vramattribute((cnt\20),0,(cntap/80))<=(cntap\80) and ((vramattribute((cnt\20),1,(cntap/80))&8)!0)=0 /*and ((vramattribute((cntx\20),1,(cnt/80))&8)!0)=0*/{cntx=cnt}:loop:if vramattribute((cntx\20),0,(cnt/80))<=(cnt\80) and ((vramattribute((cntx\20),1,(cnt/80))&8)!0)=0{vramattributem((cnt\80),(cnt/80),0)=vramattribute((cntx\20),1,(cnt/80))}:if crtmodectrl=0{cntap=cnt:repeat 20:if vramattribute((cnt\20),0,(cntap/80))<=(cntap\80) and ((vramattribute((cnt\20),1,(cntap/80))&8)!0)=1/* and ((vramattribute((cnt\20),1,(cntap/80))&16)!0)=0*/{cntx=cnt}:loop:if vramattribute((cntx\20),0,(cnt/80))<=(cnt\80) and ((vramattribute((cntx\20),1,(cnt/80))&8)!0)=1 /*and ((vramattribute((cnt\20),1,(cntap/80))&16)!0)=0*/{vramattributem((cnt\80),(cnt/80),1)=vramattribute((cntx\20),1,(cnt/80))}/*:cntap=cnt:repeat 20:if vramattribute((cnt\20),0,(cntap/80))<=(cntap\80) and ((vramattribute((cnt\20),1,(cntap/80))&8)!0)=1 and ((vramattribute((cnt\20),1,(cntap/80))&16)!0)=1{cntx=cnt}:loop:if vramattribute((cntx\20),0,(cnt/80))<=(cnt\80) and ((vramattribute((cntx\20),1,(cnt/80))&8)!0)=1 and ((vramattribute((cntx\20),1,(cnt/80))&16)!0)=1{vramattributem((cnt\80),(cnt/80),2)=vramattribute((cntx\20),1,(cnt/80))}*/}:grpccnt=cnt
z80memaccess (vramaddr+(120*(grpccnt/80))+((grpccnt\80)*((displaydispc2(pc8001widthflag|(colorgraphicmode<<1))=0)+1)))&0xFFFF,0,1:fontid=stat/*z80readmem(vramaddr+(120*(grpccnt/80))+((grpccnt\80)*((displaydispc2(pc8001widthflag|(colorgraphicmode<<1))=0)+1)))*/
attributedata=vramattributem((cnt\80),(cnt/80),0) | (vramattributent(cnt/80)&119)
attributedata2=vramattributem((cnt\80),(cnt/80),3)
if colourchanged=1 or colorgraphicmode=1{
switch crtmodectrl
case 0
//if colorgraphicmode=0 and grpmode=1{palcolor_hg 9+(0x10*(((vramattributent(cnt/80)>>3)&0x1)=0)):palletedcolorchkold=256}else{palletedcolorchk=(vramattributem((cnt\80),(cnt/80),/*1+((((attributedata2>>7)and(attributedata2>>3))|((attributedata2>>4)&(vramattributem((cnt\80),(cnt/80),0)>>3)))&0x1)*/1)>>5)+(0x10*(((vramattributent(cnt/80)>>3)&0x1)=0))+(0x20*((grpmode=0))):if palletedcolorchkold!palletedcolorchk{palcolor_hg palletedcolorchk}:palletedcolorchkold=palletedcolorchk}
if colorgraphicmode=0 and grpmode=1{palcolor_hg 9+(0x10*(((vramattributent(cnt/80)>>3)&0x1)=0)):palletedcolorchkold=256}else{palletedcolorchk=(vramattributem((cnt\80),(cnt/80),/*1+((((attributedata2>>7)and(attributedata2>>3))|((attributedata2>>4)&(vramattributem((cnt\80),(cnt/80),0)>>3)))&0x1)*/1)>>5)+(0x10*(((vramattributent(cnt/80)>>3)&0x1)=0))/*+(0x20*((grpmode=0)))*/:if palletedcolorchkold!palletedcolorchk{palcolor_hg palletedcolorchk}:palletedcolorchkold=palletedcolorchk}
swbreak
case 1
palcolor_hg 9+(0x10*(((vramattributent(cnt/80)>>3)&0x1)=0)):palletedcolorchkold=256
swbreak
swend
colourchanged=0
}
//if cursx!-1 and cursy!-1{if (gettine\blinktimest(blinkingtime))<(blinktimest(blinkingtime)/2){if cursx=(grpccnt\80) and cursy=(grpccnt/80){boxf ((cursx/((pc8001widthflag=0)+1))*8),(cursy*8),((cursx/((pc8001widthflag=0)+1))*8)+7,(cursy*8)+7}}}
//if grpmode=0{attributedata=vramattributem((cnt\80),(cnt/80),0):palcolor_hg (vramattributem((cnt\80),(cnt/80),1+((attributedata>>7)&0x1))>>5)}
//dialog attributedata
//stop
if attributedata&0x1{}else{
if (displaydispc3(pc8001widthflag|(colorgraphicmode<<1))=0)=0 and grpccnt\2=1{}else{
if (((attributedata2&128)!0) and ((attributedata2&8)=0)) or (((attributedata2&16)!0) and ((attributedata2&8)=8)) {
repeat 8
if (fontid>>cnt) & 0x01{hgrect (((grpccnt\80)/(displaydispc3(pc8001widthflag|(colorgraphicmode<<1))+1))*16)+8*(cnt/4)+4,((grpccnt/80)*16)+4*(cnt\4)+2,0,8,4}
loop
if cursx!-1 and cursy!-1{if (gettine\blinktimest(blinkingtime))<(blinktimest(blinkingtime)/2){if cursx=(grpccnt\80) and cursy=(grpccnt/80){palcolor_hg 0+(0x10*(((vramattributent(cnt/80)>>3)&0x1)=0)):hgrect ((cursx/((pc8001widthflag=0)+1))*16)+7,int(16*cursy)+8,0,16,16:palletedcolorchkold=256}}}
}else{
if cursx!-1 and cursy!-1{if (gettine\blinktimest(blinkingtime))<(blinktimest(blinkingtime)/2){if cursx=(grpccnt\80) and cursy=(grpccnt/80){hgrect ((cursx/((pc8001widthflag=0)+1))*16)+7,int(16*cursy)+8,0,16,16}}}
/*fontidx="":lpoke fontidx,0,fontid
dialog fontidx*/
if attributedata&0x4{hgrect ((int(double(0.5*((pc8001widthflag!0)+1))*(grpccnt\80)))*16)+7,int(16*(grpccnt/80))+8,0,16,16:colourchanged=1:if crtmodectrl=0{palcolor_hg bgcolor}else{palcolor_hg 8}:palletedcolorchkold=256}
if cursx!-1 and cursy!-1{if (gettine\blinktimest(blinkingtime))<(blinktimest(blinkingtime)/2){if cursx=(grpccnt\80) and cursy=(grpccnt/80){colourchanged=1:if crtmodectrl=0{palcolor_hg bgcolor}else{palcolor_hg 8}:palletedcolorchkold=256}}}
if (attributedata&0x1)=0 and (attributedata&0x2)=2 and (gettine\(blinktimest(blinkingtime)*2))>((blinktimest(blinkingtime)*2)/4){hgrect ((int(double(0.5*((pc8001widthflag!0)+1))*(grpccnt\80)))*16)+7,((grpccnt/80)*16)+8,0,16,16:colourchanged=1:if crtmodectrl=0{palcolor_hg bgcolor}else{palcolor_hg 8}:palletedcolorchkold=256}
pos ((grpccnt\80)/(displaydispc3(pc8001widthflag|(colorgraphicmode<<1))+1))*16,int(16*(grpccnt/80))-1
fontrend_hg fontid
}
if attributedata&16{hgrect (((grpccnt\80)/(displaydispc3(pc8001widthflag|(colorgraphicmode<<1))+1))*16)+8,int(16*(grpccnt/80))+2,0,18,4}
if attributedata&32{hgrect (((grpccnt\80)/(displaydispc3(pc8001widthflag|(colorgraphicmode<<1))+1))*16)+8,int(16*(grpccnt/80))+14,0,18,5}
if attributedata&64{hgrect (((grpccnt\80)/(displaydispc3(pc8001widthflag|(colorgraphicmode<<1))+1))*16)+8,int(16*(grpccnt/80))+8,0,6,16}
}
}
loop
swbreak
swend
/*else{
switch crtmodectrl
case 0
if colorgraphicmode=0 and grpmode=1{palcolor_hg 9+(0x10*(((attributedata>>1)&0x1)=0))}else{palletedcolorchk=(vramattributem((cnt\80),(cnt/80),/*1+((((attributedata2>>7)and(attributedata2>>3))|((attributedata2>>4)&(vramattributem((cnt\80),(cnt/80),0)>>3)))&0x1)*//*1)>>5)+(0x10*(((attributedata>>1)&0x1)=0))+(0x20*((grpmode=0))):palcolor_hg palletedcolorchk}
swbreak
case 1
palcolor_hg 9+(0x10*(((attributedata>>1)&0x1)=0))
swbreak
swend
}*/
//gettme2=gettime(6)-gettmex2:if gettme2<0{gettme2+=1000}
//if crtmodectrl=0{}
hgdraw 4
pos 0,0
hgcapture
gsel 6,0:pos 0,0:gzoom 8*dispysize2(pc8001widthflag|(colorgraphicmode<<1)),int(8*dispysize(grpheight25)),5,0,0,int(15.999999*dispysize2(pc8001widthflag|(colorgraphicmode<<1))),int(16*dispysize(grpheight25))
gsel 3,0
pos 0,0
gzoom 640,400,6,0,0,8*dispysize2(pc8001widthflag|(colorgraphicmode<<1)),int(8*dispysize(grpheight25)),(grpbfsetting!0):if grpbfsetting<=1{}else{if grpbfsetting=2{ipmb_smoothingtype1 0,0,ginfo(26),ginfo(27)}else{if grpbfsetting>=3 and grpbfsetting<=12{ipmb_smoothingtype2 0,0,ginfo(26),ginfo(27),(grpbfsetting-1)}else{if grpbfsetting>=13 and grpbfsetting<=22{ipmb_unsharpmasking 0,0,ginfo(26),ginfo(27),1,double(grpbfsetting-12)}else{if grpbfsetting>=23 and grpbfsetting<=32{ipmb_smoothinggauss 0,0,ginfo(26),ginfo(27),1,double(grpbfsetting-22)}else{if grpbfsetting>=33 and grpbfsetting<=42{ipmb_sharp 0,0,ginfo(26),ginfo(27),double(grpbfsetting-32)}else{if grpbfsetting>=43{ipmb_smoothingtype1 0,0,ginfo(26),ginfo(27)}}}}}}}
redraw 1
//statx+=24000
}else{gsel 3,0:color 0,0,0:boxf:redraw 1}
}
await
//vbi=1
interruptformt=1:functyper=3|(0<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop:interruptformt=1
interruptformt=interruptformtbakfordw
return

*appexitforemuendproc
#ifdef formadgeinitfunc
interruptformt=1:functyper=1|(0xF<<4):repeat plaginmax:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,varptr(exrom(0)):lpoke plaginconfptr,4*3,varptr(rom):lpoke plaginconfptr,4*4,varptr(fontrom):lpoke plaginconfptr,4*5,varptr(cassettestateptr):lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):lpoke plaginconfptr,4*7,sysfunctyper:pluginid=cnt:gosub plaginptr(cnt)}:loop:interruptformt=0
#endif
hgbye
end

*keydown
if interruptformt=0{interruptformt=1:interruptformtk=1}
wparam2kdku=wparam
functyper=0|(2<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,wparam2kdku:lpoke plaginconfptr,4*4,varptr(wparam2kdku):lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop
vbismacs=0
keytemp=keymap(wparam2kdku)
if keytemp=0xFF{if interruptformtk=1{interruptformt=0:interruptformtk=0}:return}
keyio((keytemp>>4)&0xF)|=1<<(keytemp&0xF)
if wparam2kdku=37 or wparam2kdku=40{keytemp=0x86:keyio((keytemp>>4)&0xF)|=1<<(keytemp&0xF)}
if interruptformtk=1{interruptformt=0:interruptformtk=0}
return
*keyup
if interruptformt=0{interruptformt=1:interruptformtk=1}
wparam2kdku=wparam
functyper=1|(2<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*3,wparam2kdku:lpoke plaginconfptr,4*4,varptr(wparam2kdku):lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop
keytemp=keymap(wparam2kdku)
if keytemp=0xFF{if interruptformtk=1{interruptformt=0:interruptformtk=0}:return}
keyio((keytemp>>4)&0xF)&=(0xFF^(1<<(keytemp&0xF)))
if wparam2kdku=37 or wparam2kdku=40{keytemp=0x86:keyio((keytemp>>4)&0xF)^=1<<(keytemp&0xF)}
if interruptformtk=1{interruptformt=0:interruptformtk=0}
return

*z80interruptioncall
if usejit=0{
z80interrupt address,0,plaginconf(120,pluginid)
}else{
z80jitinterrupt address,plaginconf(120,pluginid),0
}
return
*z80nminterruptioncall
if usejit=0{
z80nminterrupt address,0
}else{
z80jitnminterrupt address
}
return
*z80memoryget
z80memaccess plaginconf(120,pluginid),0,1
statue=stat
return statue
*z80memoryput
z80memaccess plaginconf(120,pluginid),plaginconf(121,pluginid),0
return
*controllercall
dupptr controllerlblx,plaginconf(121,pluginid),4*16,4
joyGetPosEx controllerlblx, plaginconf(120,pluginid)
return
*pluginload
#ifdef formadgeinitfunc
interruptformt=1:functyper=0|(0xF<<4):dupptr pluginliste,plaginconf(120,pluginid),1024,2:exist pluginliste
if strsize!-1{lpoke plaginptr(plaginmax),0,_faddproc("plugins/"+pluginliste):if lpeek(plaginptr(plaginmax),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,varptr(exrom(0)):lpoke plaginconfptr,4*3,varptr(rom):lpoke plaginconfptr,4*4,varptr(fontrom):lpoke plaginconfptr,4*5,varptr(cassettestateptr):lpoke plaginconfptr,4*6,varptr(plaginconf(0,plaginmax)):lpoke plaginconfptr,4*7,sysfunctyper:pluginid=plaginmax:gosub plaginptr(plaginmax)}
plaginmax+=1}:interruptformt=0
#endif
return
*controllercall2
controllerlblx2=0
jstick controllerlblx2, plaginconf(120,pluginid)
return controllerlblx2
*sysfunc_arduino_init
arduino_init plaginconf(120,pluginid),plaginconf(121,pluginid)
statue=stat
return statue
*sysfunc_arduino_bye
arduino_bye
return
*sysfunc_arduino_query
arduino_query
return
*sysfunc_delay
delay plaginconf(120,pluginid)
return
*sysfunc_pinmode
pinmode plaginconf(120,pluginid),plaginconf(121,pluginid)
return
*sysfunc_digitalWrite
digitalWrite plaginconf(120,pluginid),plaginconf(121,pluginid)
return
*sysfunc_analogWrite
analogWrite plaginconf(120,pluginid),plaginconf(121,pluginid)
return
*sysfunc_digitalRead
return digitalRead(plaginconf(120,pluginid))
*sysfunc_analogRead
return analogRead(plaginconf(120,pluginid))
*sysfunc_analogReport
analogReport plaginconf(120,pluginid),plaginconf(121,pluginid)
return
*sysfunc_digitalReport
digitalReport plaginconf(120,pluginid),plaginconf(121,pluginid)
return
*sysfunc_analogInterval
analogInterval plaginconf(120,pluginid),plaginconf(121,pluginid)
return
*sysfunc_arduino_exec
arduino_exec
statue=stat
return statue
*sysfunc_arduino_error
return arduino_error
*sysfunc_arduino_stat
return arduino_stat
*sysfunc_arduino_ready
return arduino_ready
*sysfunc_arduino_rx
return arduino_rx
*z80ioget
z80memaccess plaginconf(120,pluginid),0,3
statue=stat
return statue
*z80ioput
z80memaccess plaginconf(120,pluginid),plaginconf(121,pluginid),2
return
*sysfunc_arduino_firm_ver
return arduino_firm_ver
*sysfunc_hspext
switch plaginconf(120,pluginid)
case 0
gfdec plaginconf(121,pluginid),plaginconf(122,pluginid),plaginconf(123,pluginid)
statue=stat
return statue
swbreak
case 1
gfinc plaginconf(121,pluginid),plaginconf(122,pluginid),plaginconf(123,pluginid)
statue=stat
return statue
swbreak
case 2
gfcopy plaginconf(121,pluginid)
statue=stat
return statue
swbreak
case 3
emath plaginconf(121,pluginid)
statue=stat
return statue
swbreak
case 4
dupptr stringforemstr,plaginconf(121,pluginid),plaginconf(123,pluginid)+1,2
emstr stringforemstr,plaginconf(122,pluginid),plaginconf(123,pluginid)
statue=stat
return statue
swbreak
case 5
dupptr stringforemstr,plaginconf(121,pluginid),65536,4
dupptr stringforemstr2,plaginconf(122,pluginid),65536,2
emcnv stringforemstr,stringforemstr2
statue=stat
return statue
swbreak
case 6
dupptr stringforemstr,plaginconf(121,pluginid),65536,4
emint stringforemstr,plaginconf(122,pluginid)
statue=stat
return statue
swbreak
case 7
dupptr stringforemstr,plaginconf(121,pluginid),65536,4
emsin stringforemstr,plaginconf(122,pluginid)
statue=stat
return statue
swbreak
case 8
dupptr stringforemstr,plaginconf(121,pluginid),65536,4
emcos stringforemstr,plaginconf(122,pluginid)
statue=stat
return statue
swbreak
case 9
dupptr stringforemstr,plaginconf(121,pluginid),65536,4
ematan stringforemstr,plaginconf(122,pluginid),plaginconf(123,pluginid)
statue=stat
return statue
swbreak
case 10
dupptr stringforemstr,plaginconf(121,pluginid),65536,4
emsqr stringforemstr,plaginconf(122,pluginid)
statue=stat
return statue
swbreak
case 11
sysexit plaginconf(121,pluginid)
statue=stat
return statue
swbreak
case 12
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
dupptr stringforemstr2,plaginconf(122,pluginid),65536,2
fxcopy stringforemstr,stringforemstr2,plaginconf(123,pluginid)
statue=stat
return statue
swbreak
case 13
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
dupptr stringforemstr2,plaginconf(122,pluginid),65536,2
fxren stringforemstr,stringforemstr2
statue=stat
return statue
swbreak
case 14
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
fxinfo stringforemstr,plaginconf(122,pluginid),plaginconf(123,pluginid)
statue=stat
return statue
swbreak
case 15
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
fxaset stringforemstr,plaginconf(122,pluginid)
statue=stat
return statue
swbreak
case 16
dupptr stringforemstr,plaginconf(121,pluginid),65536,4
dupptr stringforemstr2,plaginconf(122,pluginid),65536,2
fxaget stringforemstr,stringforemstr2
statue=stat
return statue
swbreak
case 17
dupptr stringforemstr,plaginconf(121,pluginid),65536,4
dupptr stringforemstr2,plaginconf(122,pluginid),65536,2
fxtget stringforemstr,stringforemstr2
statue=stat
return statue
swbreak
case 18
dupptr stringforemstr,plaginconf(121,pluginid),65536,4
dupptr stringforemstr2,plaginconf(122,pluginid),65536,2
fxtset stringforemstr,stringforemstr2
statue=stat
return statue
swbreak
case 19
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
dupptr stringforemstr2,plaginconf(122,pluginid),65536,2
fxshort stringforemstr,stringforemstr2
statue=stat
return statue
swbreak
case 20
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
dupptr stringforemstr2,plaginconf(122,pluginid),65536,2
fxlink stringforemstr,stringforemstr2
statue=stat
return statue
swbreak
case 21
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
fxdir stringforemstr,plaginconf(122,pluginid)
statue=stat
return statue
swbreak
case 22
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
clipset stringforemstr
statue=stat
return statue
swbreak
case 23
dupptr stringforemstr,plaginconf(121,pluginid),plaginconf(122,pluginid)+1,2
clipget stringforemstr,plaginconf(122,pluginid)
statue=stat
return statue
swbreak
case 24
clipsetg
statue=stat
return statue
swbreak
case 25
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
aplsel stringforemstr,plaginconf(122,pluginid)
statue=stat
return statue
swbreak
case 26
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
aplobj stringforemstr,plaginconf(122,pluginid)
statue=stat
return statue
swbreak
case 27
aplact
statue=stat
return statue
swbreak
case 28
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
aplstr stringforemstr
statue=stat
return statue
swbreak
case 29
aplkey plaginconf(121,pluginid),plaginconf(122,pluginid)
statue=stat
return statue
swbreak
case 30
aplkeyu plaginconf(121,pluginid),plaginconf(122,pluginid)
statue=stat
return statue
swbreak
case 31
aplkeyd plaginconf(121,pluginid),plaginconf(122,pluginid)
statue=stat
return statue
swbreak
case 32
aplfocus
statue=stat
return statue
swbreak
case 33
dupptr stringforemstr,plaginconf(121,pluginid),plaginconf(122,pluginid)+1,2
aplget stringforemstr,plaginconf(122,pluginid)
statue=stat
return statue
swbreak
case 34
dupptr stringforemstr,plaginconf(121,pluginid),65536,4
apledit stringforemstr,plaginconf(122,pluginid),plaginconf(123,pluginid)
statue=stat
return statue
swbreak
case 35
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
dupptr stringforemstr2,plaginconf(122,pluginid),65536,2
selfolder stringforemstr,stringforemstr2
statue=stat
return statue
swbreak
case 36
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
lzcopy stringforemstr
statue=stat
return statue
swbreak
case 37
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
lzdist stringforemstr
statue=stat
return statue
swbreak
case 38
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
dupptr stringforemstr2,plaginconf(122,pluginid),65536,2
pipeexec stringforemstr,stringforemstr2,plaginconf(123,pluginid)
statue=stat
return statue
swbreak
case 39
pipeput plaginconf(121,pluginid)
statue=stat
return statue
swbreak
case 40
dupptr stringforemstr,plaginconf(121,pluginid),65536,2
pipeget stringforemstr
statue=stat
return statue
swbreak
case 41
dupptr stringforemstr,plaginconf(121,pluginid),65536,4
dupptr stringforemstr2,plaginconf(122,pluginid),65536,2
dirlist2 stringforemstr,stringforemstr2,plaginconf(123,pluginid),plaginconf(124,pluginid)
statue=stat
return statue
swbreak
case 42
dupptr stringforemstr,plaginconf(121,pluginid),655360,2
dirlist2r stringforemstr
statue=stat
return statue
swbreak
case 43
dirlist2h plaginconf(121,pluginid),plaginconf(122,pluginid)
statue=stat
return statue
swbreak
swend
return
*sysfunc_z80stackpeek
return stackpeek(0,plaginconf(120,pluginid),plaginconf(121,pluginid))
*sysfunc_z80stackpoke
stackpoke 0,plaginconf(120,pluginid),plaginconf(121,pluginid),plaginconf(122,pluginid)
return
*sysfunc_subz80acs
dupptr address4sz80,plaginconf(120,pluginid),4,4
return z80run_c(address4sz80,plaginconf(121,pluginid)+1)
*sysfunc_subz80acs2
switch plaginconf(120,pluginid)
case 0
return stackpeek(plaginconf(121,pluginid)+1,plaginconf(122,pluginid),plaginconf(123,pluginid))
swbreak
case 1
stackpoke plaginconf(121,pluginid)+1,plaginconf(122,pluginid),plaginconf(123,pluginid),plaginconf(124,pluginid)
return 0
swbreak
case 2
dupptr address4sz80,plaginconf(121,pluginid),4,4
z80interrupt address4sz80,plaginconf(122,pluginid),plaginconf(123,pluginid)
return 0
swbreak
case 3
dupptr address4sz80,plaginconf(121,pluginid),4,4
z80nminterrupt address4sz80,plaginconf(122,pluginid)
return 0
swbreak
swend
return

*interruptlbl
wparam2=wparam
if interruptformt=1{return}
if wparam2=3 and interruptformt=0{// and emulatorexeci=1{
/*if cntmain\32>24{
vbi=1
}else{
vbi=0
}*/
interruptformtbak=interruptformt
interruptformt=1
//gosub *bpsoundctlr
//if (interruptix\2)=0 and (vbis=1) and (((((interruptlevel>>3)&1)=1) or (interruptlevel&0x7)>0)){if vbismacs=1{if usejit=0{z80interrupt address,0,2*1}else{z80jitinterrupt address,2*1,0}}:vbis=0}
if oprestruct=0{
if (interruptphb&1)!0 and (interruptix\100)=0 and (((((interruptlevel>>3)&1)=1) or (interruptlevel&0x7)>1)){if usejit=0{z80interrupt address,0,2*2}else{z80jitinterrupt address,2*2,0}}
if (interruptix\3)=0 and ((((interruptlevel>>3)&1)=1) or (interruptlevel&0x7)>2){if usejit=0{z80interrupt address,0,2*3}else{z80jitinterrupt address,2*3,0}}
if (interruptix\5)=0 and ((((interruptlevel>>3)&1)=1) or (interruptlevel&0x7)>4){if usejit=0{z80interrupt address,0,2*5}else{z80jitinterrupt address,2*5,0}}
if vbis=1{vbis=0}
emulatorexeci=0
interruptix+=1:if interruptix>=100{interruptix=0}
}
interruptformt=interruptformtbak
return
}
/*if wparam2=2{
cntmain+=1
}*/
if wparam2=4 and interruptformt=0{
interruptformtbak=interruptformt
interruptformt=1
vbi=(vbi=0)
interruptformt=interruptformtbak
return
}
if wparam2=1 and interruptformt=0{
interruptformtbak=interruptformt
interruptformt=1
//vbi=(vbi=0)
//if vbi=1{
vbi=1
//gosub *drawbackground
//gosub *drawforeground
//interruptformt=1:functyper=2|(0<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop:interruptformt=0
//}
//if funcptruster(8)!0{ldim funcptrusterlbl,1:lpoke funcptrusterlbl,0,funcptruster(8):gosub funcptrusterlbl}else{z80interrupt var_27,var_29,0,0xE0}
interruptformt=interruptformtbak
return
}
if wparam2=2 and interruptformt=0{
interruptformtbak=interruptformt
interruptformt=1
gosub *bpsoundctlr
interruptformt=interruptformtbak
return
}
return

*vblupdatejob2
oprestruct=0
if cntmain\32>24{
vbi=1
}else{
vbi=0
}
emulatorexeci=1
vbismacs=0
interruptformt=0
if cntmain\21000*2=0 and cntmain!0{
gosub *drawbackground
gosub *drawforeground
gosub *bpsoundctlr
interruptformt=1:functyper=2|(0<<4):repeat plaginmax:gosub *bpsoundctlr:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop:interruptformt=0
await
vbis=0
}
interruptformt=1:functyper=0|(0<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop:interruptformt=0
cntmain+=1
vbismacs=1
emulatorexeci=0
oprestruct=1
interruptformt=1
return
*vblupdatejob
cntmain=0:oprestruct=1
interruptformt=0
gosub *drawbackground
gosub *drawforeground
interruptformt=1:functyper=2|(0<<4):repeat plaginmax:if plaginconf(0,cnt)=1{if plaginconf(1,cnt)=functyper or plaginconf(2,cnt)=functyper or plaginconf(3,cnt)=functyper or plaginconf(4,cnt)=functyper or plaginconf(5,cnt)=functyper{}else{continue cnt+1}}else{continue cnt+1}:if lpeek(plaginptr(cnt),0)!0{memfile plaginconfptr:lpoke plaginconfptr,4*0,varptr(plaginconfptr):lpoke plaginconfptr,4*1,functyper:lpoke plaginconfptr,4*2,sysfunctyper:lpoke plaginconfptr,4*6,varptr(plaginconf(0,cnt)):pluginid=cnt:gosub plaginptr(cnt)}:loop:interruptformt=0
emulatorexeci=1
return

*bpsoundctlr
/*if beepenable=1{BeepIsDone:if stat=1{BeepPlay 2400, 0x7FFFFFFF}:BeepRestart}else{BeepPause}
return*/
goto bpsoundctrlptr(playingbeep=0)
if playingbeep=0{
if beepenable=1{
playingbeep=1
;waveOutSine 2400,0.1,0.01
//mmplay 0
}else{waveOutPause hWaveOut@_WAVEOUT_M_}}else{if beepenable=0{waveOutPause hWaveOut@_WAVEOUT_M_:playingbeep=0}}
return
*bpsoundctlr_a
if beepenable=1{
playingbeep=1
BeepIsDone:if stat=1{BeepPlay 2400, 0x7FFFFFFF}
BeepRestart
}else{BeepPause}
return
*bpsoundctlr_b
if beepenable=0{BeepPause:playingbeep=0}
return

*clkdownmvup
if interruptformt=0{interruptformt=1:interruptformtk=1}
gselnowjckd=ginfo(3)
gsel 0,0
dim lp_ggxy,2
if wparam=1{
lparam2=lparam
lp_ggxy=((wpeek(lparam2,0)*dispysize2(pc8001widthflag|(colorgraphicmode<<1)))/ginfo(12))+6,(wpeek(lparam2,2)*dispysize(grpheight25))/ginfo(13)
litepeninp=(((vbi<<7)|(lp_ggxy(0)&127))<<0)|((lp_ggxy(1)&63)<<8)
poke upd3301stat,0,peek(upd3301stat,0)|1
}
gsel gselnowjckd,0
if interruptformtk=1{interruptformt=0:interruptformtk=0}
return
